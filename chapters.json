{
    "Chapter 1": ". Introduction \nI think there is a world market for maybe five computers.  \n-Thomas Watson, Chairman of IBM, 1943 There is no reason anyone would want a computer in their home.  \n-Ken Olson, President of Dig ital Equipment Corporation, 1977 \nOne of the more surprising developments of the last few decades has been the ascendance of \ncomputers to a position of prevalence in human  affairs. Today there are more computers in \nour homes and offices than there are people who live and work in them. Yet many of these computers are not recognized as such by their users. In this chapter, I'll explain what \nembedded systems are and where they are f ound. I will also intr oduce the subject of \nembedded programming, explain why I have sele cted C and C++ as the languages for this \nbook, and describe the hardware used in the examples.  \n1.1 What Is an Embedded System? \nAn embedded system  is a combination of computer ha rdware and software, and perhaps \nadditional mechanical or othe r parts, designed to perform a specific function. A good example \nis the microwave oven. Almost every household has one, and tens of millions of them are used every day, but very few people realize that a processor and software are involved in the \npreparation of their lunch or dinner.  \nThis is in direct contrast to the personal com puter in the family room. It too is comprised of \ncomputer hardware and software and mechan ical components (disk drives, for example). \nHowever, a personal computer is not designed to perform a speci fic function. Rather, it is able \nto do many different things. Many people use the term general-purpose computer  to make \nthis distinction clear. As shipped, a genera l-purpose computer is a blank slate; the \nmanufacturer does not know what the customer will do with it. One customer may use it for a \nnetwork file server, another may use it exclusiv ely for playing games, and a third may use it \nto write the next great American novel.  \nFrequently, an embedded system is a component within  some larger system. For example, modern cars and \ntrucks contain many embedded systems. One embedded system controls the anti-lock brakes, another monitors and controls the vehicle's emissions, and a third displa ys information on the dashboard. In some cases, these \nembedded systems are connected by some sort of a communications network, but that is certainly not a \nrequirement.  \nAt the possible risk of confusing you, it is important to point out that a general-purpose computer is itself made \nup of numerous embedded systems. For example, my computer consists of a keyboard, mouse, video card, \nProgramming Embedded Systems in C and C++ \n- 12 - modem, hard drive, floppy drive, and sound card-each of  which is an embedded system. Each of these devices \ncontains a processor and software and is designed to perform a specific function. For example, the modem is designed to send and receive digital data over an analog telephone line. That's it. And all of the other devices can \nbe summarized in a single sentence as well.  \nIf an embedded system is designed well, the existence of the processor and software could be completely \nunnoticed by a user of the device. Su ch is the case for a microwave oven, V CR, or alarm clock. In some cases, it \nwould even be possible to build an equivalent device that does not contain the processor and software. This could be done by replacing the combination with a custom integrated circuit that performs the same functions in hardware. However, a lot of flexibility is lost when a desi gn is hard-coded in this way. It is much easier, and \ncheaper, to change a few lines of software th an to redesign a piece of custom hardware.  \n1.1.1 History and Future  \nGiven the definition of embedded systems earlier in  this chapter, the first such systems could \nnot possibly have appeared befo re 1971. That was the year Inte l introduced the world's first \nmicroprocessor. This chip, the 4004, was designe d for use in a line of business calculators \nproduced by the Japanese company Busicom. In  1969, Busicom asked Intel to design a set of \ncustom integrated circuits-one for each of their new calculator models. The 4004 was Intel's \nresponse. Rather than design custom hard ware for each calculator, Intel proposed a \ngeneral-purpose circuit that could be used th roughout the entire line  of calculators. This \ngeneral-purpose processor was design ed to read and execute a set of \ninstructions-software-stored in an external me mory chip. Intel's idea was that the software \nwould give each calculator it s unique set of features.  \nThe microprocessor was an overnight success, and its use increased steadily over the next \ndecade. Early embedded applications included unmanned space probes, computerized traffic \nlights, and aircraft f light control systems. In the 1980s, embedded systems quietly rode the \nwaves of the microcomputer age and brought micr oprocessors into every part of our personal \nand professional lives. Many of the electronic de vices in our kitchens (bread machines, food \nprocessors, and microwave ovens), living rooms (t elevisions, stereos, and remote controls), \nand workplaces (fax machines, pagers, laser prin ters, cash registers, and credit card readers) \nare embedded systems.  \nIt seems inevitable that the number of embedded systems will continue to increase rapidly. \nAlready there are promising new embedded devi ces that have enormous market potential: \nlight switches and thermostats th at can be controlled by a central  computer, intelligent air-bag \nsystems that don't inflate when children or sma ll adults are present, palm-sized electronic \norganizers and personal digital assistants (P DAs), digital cameras, and dashboard navigation \nsystems. Clearly, individuals who possess the ski lls and desire to design the next generation \nof embedded systems will be in demand for quite some time.  \nProgramming Embedded Systems in C and C++ \n- 13 - 1.1.2 Real-Time Systems  \nOne subclass of embedded systems is worthy of  an introduction at this point. As commonly \ndefined, a real-time system  is a computer system that has tim ing constraints. In other words, a \nreal-time system is partly specified in terms of its ability to make certain calculations or \ndecisions in a timely manner. These important ca lculations are said to have deadlines for \ncompletion. And, for all practical purposes, a mi ssed deadline is just as bad as a wrong \nanswer.  \nThe issue of what happens if a deadline is missed is a crucial one. For example, if the \nreal-time system is part of an airplane's flight  control system, it is possi ble for the lives of the \npassengers and crew to be endangered by a singl e missed deadline. However, if instead the \nsystem is involved in satellite communication, the damage could be limited to a single corrupt \ndata packet. The more severe the consequen ces, the more likely it will be said that the \ndeadline is \"hard\" and, thus, the system a hard  real-time system. Real-time systems at the \nother end of this continuum are sa id to have \"soft\" deadlines.  \nAll of the topics and examples presented in this book are applicable to the designers of \nreal-time systems. However, the designer of a real-time system must be more diligent in his work. He must guarantee reliab le operation of the software and hardware under all possible \nconditions. And, to the degree that human lives depend upon th e system's proper execution, \nthis guarantee must be backed by engineering calculations and desc riptive paperwork.  \n1.2 Variations on the Theme \nUnlike software designed for general-purpose computers, embedded software cannot usually \nbe run on other embedded systems without significant modification. This is mainly because of the incredible variety in the underlying hardwa re. The hardware in each embedded system is \ntailored specifically to the application, in or der to keep system costs low. As a result, \nunnecessary circuitry is eliminated and hardware  resources are shared wherever possible. In \nthis section you will learn what  hardware features are common across all embedded systems \nand why there is so much variation with respect to just about everything else.  \nBy definition all embedded systems contain a pro cessor and software, but what other features \ndo they have in common? Certainl y, in order to have software, th ere must be a place to store \nthe executable code and temporary storage for ru ntime data manipulation. These take the form \nof ROM and RAM, respectively; any embedded system will have some of each. If only a small amount of memory is required, it might be contained within the same chip as the \nprocessor. Otherwise, one or both types of memo ry will reside in external memory chips.  \nAll embedded systems also contain some type  of inputs and outputs. For example, in a \nmicrowave oven the inputs are the buttons on th e front panel and a temperature probe, and the \noutputs are the human-readable display and the mi crowave radiation. It is almost always the \nProgramming Embedded Systems in C and C++ \n- 14 - case that the outputs of the embedded system ar e a function of its i nputs and several other \nfactors (elapsed time, current temperature, etc. ). The inputs to the sy stem usually take the \nform of sensors and probes, communication si gnals, or control knobs and buttons. The outputs \nare typically displays, comm unication signals, or changes to the physical world. See Figure 1-1  \nfor a general example of an embedded system.  \nFigure 1-1. A generic embedded system  \n \nWith the exception of these few common featur es, the rest of the embedded hardware is \nusually unique. This variation is the result of many competi ng design criteria. Each system \nmust meet a completely different set of requi rements, any or all of  which can affect the \ncompromises and tradeoffs made during the deve lopment of the product. For example, if the \nsystem must have a production cost of less than  $10, then other things -like processing power \nand system reliability-might need to be s acrificed in order to  meet that goal.  \nOf course, production cost is only one of the possible co nstraints under which embedded \nhardware designers work. Other common de sign requirements include the following:  \nProcessing power   \nThe amount of processing power necessary to get the job done. A common way to \ncompare processing power is the MIPS (millions  of instructions per second) rating. If \ntwo processors have ratings of 25 MIPS and 40 MIPS, the latter is said to be the more powerful of the two. However, other important  features of the pr ocessor need to be \nconsidered. One of these is th e register width, which typical ly ranges from 8 to 64 bits. \nToday's general-purpose computers use 32- and 64-bit processors exclusively, but \nembedded systems are still commonly built with older and less co stly 8- and 16-bit \nprocessors.  \nMemory   \nThe amount of memory (ROM and RAM) re quired to hold the executable software \nand the data it manipulates. He re the hardware designer must usually make his best \nestimate up front and be prepared to increas e or decrease the actual amount as the \nsoftware is being developed. The amount of  memory required can also affect the \nProgramming Embedded Systems in C and C++ \n- 15 - processor selection. In genera l, the register width of a processor establ ishes the upper \nlimit of the amount of memory it can access (e.g.,  an 8-bit address register can select \none of only 256 unique memory locations).[1]  \n[1] Of course, the smaller the register width, the more likely it is that the processor employs tricks like multiple \naddress spaces to support more memory. A few hundred bytes just  isn't enough to do much of anything. Several thousand \nbytes is a more likely minimum, even for an 8-bit processor. \nDevelopment cost   \nThe cost of the hardware and software design processes. This is a fixed, one-time cost, \nso it might be that money is no object (usually  for high-volume products ) or that this is \nthe only accurate measure of system cost  (in the case of a small number of units \nproduced).  \nNumber of units   \nThe tradeoff between production cost and deve lopment cost is affected most by the \nnumber of units expected to be produced  and sold. For example, it is usually \nundesirable to develop your own custom  hardware components for a low-volume \nproduct.  \nExpected lifetime   \nHow long must the system continue to f unction (on average)? A month, a year, or a \ndecade? This affects all sorts of design d ecisions from the selection of hardware \ncomponents to how much the system may cost to develop and produce.  \nReliability   \nHow reliable must the final pr oduct be? If it is a children's toy, it doesn't always have \nto work right, but if it's a part of a space s huttle or a car, it had sure better do what it is \nsupposed to each and every time.  \nIn addition to these general requirements, there are the detailed functional requirements of the \nsystem itself. These are the things that give  the embedded system its unique identity as a \nmicrowave oven, pacemaker, or pager.  \nTable 1-1  illustrates the range of po ssible values for each of the previous design requirements. \nThese are only estimates and should not be taken too seriously. In some cases, two or more of the criteria are linked. For example, increases in processing power could lead to increased \nproduction costs. Conversely, we might imagine th at the same increase in processing power \nwould have the effect of decreasing the develo pment costs-by reducing the complexity of the \nhardware and software design. So the values in a particular column do not necessarily go \ntogether.  \nProgramming Embedded Systems in C and C++ \n- 16 - Table 1-1. Common Design Requi rements for Embedded Systems  \nCriterion Low Medium High \nProcessor 4- or 8-bit 16-bit 32- or 64-bit  \nMemory < 16 KB 64 KB to 1 MB > 1 MB \nDevelopment cost < $100,000 $100,000 to $1,000,000 > $1,000,000 \nProduction cost < $10 $10 to $1,000 > $1,000 \nNumber of units < 100 100-10,000 > 10,000 \nExpected lifetime days, weeks, or months years decades \nReliability may occasionally fail must work reliably must be fail-proof \nIn order to simultaneously demonstrate the vari ation from one embedded system to the next \nand the possible effects of these design requirements on the hardware, I will now take some \ntime to describe three embedded systems in some  detail. My goal is to put you in the system \ndesigner's shoes for a few moments before begi nning to narrow our discussion to embedded \nsoftware development.  \n1.2.1 Digital Watch  \nAt the end of the evolutionary path that bega n with sundials, water cl ocks, and hourglasses is \nthe digital watch. Among its many features are th e presentation of the date and time (usually \nto the nearest second), the measur ement of the length of an even t to the neares t hundredth of a \nsecond, and the generation of an annoying litt le sound at the beginning of each hour. As it \nturns out, these are very simple tasks that do not require very much  processing power or \nmemory. In fact, the only reason to employ a proce ssor at all is to suppo rt a range of models \nand features from a single hardware design.  \nThe typical digital watch contains a simple, in expensive 8-bit processor. Because such small \nprocessors cannot address very much memory, this  type of processor usually contains its own \non-chip ROM. And, if there are sufficient register s available, this application may not require \nany RAM at all. In fact, all of the electron ics-processor, memory, counters and real-time \nclocks-are likely to be stored in a single ch ip. The only other hardware  elements of the watch \nare the inputs (buttons) and outputs (LCD and speaker).  \nThe watch designer's goal is to create a reasona bly reliable product that has an extraordinarily \nlow production cost. If, after production, some wa tches are found to keep more reliable time \nthan most, they can be sold under a brand name  with a higher markup. Otherwise, a profit can \nstill be made by selling the watch through a disc ount sales channel. For lower-cost versions, \nthe stopwatch buttons or speaker  could be eliminated. This would limit the functionality of \nthe watch but might not even require any software changes. And, of course, the cost of all this \nProgramming Embedded Systems in C and C++ \n- 17 - development effort may be fairly high, since it will be amortized over hundreds of thousands \nor even millions of watch sales.  \n1.2.2 Video Game Player  \nWhen you pull the Nintendo-64 or Sony Playstat ion out from your entertainment center, you \nare preparing to use an embedded system. In some cases, these machines are more powerful \nthan the comparable generation of personal computers. Yet vi deo game players for the home \nmarket are relatively inexpensive compared to personal computers. It is the competing \nrequirements of high processing power and lo w production cost that keep video game \ndesigners awake at night (and their children well-fed).  \nThe companies that produce video game play ers don't usually care how much it costs to \ndevelop the system, so long as the production co sts of the resulting product are low-typically \naround a hundred dollars. They might even en courage their engineer s to design custom \nprocessors at a development cost of hundreds of  thousands of dollars each. So, although there \nmight be a 64-bit processor inside your video game  player, it is not neces sarily the same type \nof processor that would be found in a 64- bit personal computer. In all likelihood, the \nprocessor is highly specialized for the demands of the video games it is intended to play.  \nBecause production cost is so crucial in the home video game market, the designers also use \ntricks to shift the costs around. For example, one  common tactic is to move as much of the \nmemory and other peripheral elec tronics as possible off of the ma in circuit board and onto the \ngame cartridges. This helps to reduce the cost of the game player, but increases the price of \neach and every game. So, while the system migh t have a powerful 64-bit processor, it might \nhave only a few megabytes of memory on the ma in circuit board. This is just enough memory \nto bootstrap the machine to a state from wh ich it can access additional memory on the game \ncartridge.  \n1.2.3 Mars Explorer  \nIn 1976, two unmanned spacecraft arrived on the plan et Mars. As part of their mission, they \nwere to collect samples of the Martian surf ace, analyze the chemical makeup of each, and \ntransmit the results to scientists back on Earth. Those Viking missions are amazing to me. \nSurrounded by personal computers that must be rebooted almost daily, I find it remarkable \nthat more than 20 years ago a team of sc ientists and engineers successfully built two \ncomputers that survived a journey of 34 milli on miles and functioned correctly for half a \ndecade. Clearly, reliability was one of the most important requirements for these systems.  \nWhat if a memory chip had failed? Or the soft ware had bugs that caused  it to crash? Or an \nelectrical connection broke dur ing impact? There is no way to  prevent such problems from \noccurring. So, all of these potential failure poi nts and many others had to be eliminated by \nProgramming Embedded Systems in C and C++ \n- 18 - adding redundant circuitry or extra functionali ty: an extra processor here, special memory \ndiagnostics there, a hardware timer to reset th e system if the software got stuck, and so on.  \nMore recently, NASA launched the Pathfinder mi ssion. Its primary goal was to demonstrate \nthe feasibility of getting to Mars on a budget. Of course, given the advances in technology \nmade since the mid-70s, the designers didn't have to give up too much to accomplish this. They might have reduced the amount of redundanc y somewhat, but they still gave Pathfinder \nmore processing power and memory than Viki ng ever could have. The Mars Pathfinder was \nactually two embedded systems: a landing craft and a rover. The landing craft had a 32-bit \nprocessor and 128 MB of RAM; the rover, on th e other hand, had only an 8-bit processor and \n512KB. These choices probably reflect the diffe rent functional requirements of the two \nsystems. But I'm sure that production cost wa sn't much of an issue in either case.  \n1.3 C: The Least Common Denominator \nOne of the few constants across all these syst ems is the use of the C programming language. \nMore than any other, C has become the la nguage of embedded programmers. This has not \nalways been the case, and it will not continue to be so forever. However, at this time, C is the \nclosest thing there is to a standard in the em bedded world. In this section I'll explain why C \nhas become so popular and why I have chosen it and its descendent C++ as the primary \nlanguages of this book.  \nBecause successful software development is so  frequently about selecting the best language \nfor a given project, it is surprising to find th at one language has proven itself appropriate for \nboth 8-bit and 64-bit processors; in systems with bytes, kilobytes, and megabytes of memory; \nand for development teams that consist of from one to a dozen or more people. Yet this is \nprecisely the range of projects in which C has thrived.  \nOf course, C is not without advantages. It is small and fairly simple to learn, compilers are \navailable for almost every processor in us e today, and there is a very large body of \nexperienced C programmers. In addition, C has th e benefit of processor-independence, which \nallows programmers to concentrate on algorithms  and applications, rather than on the details \nof a particular processor arch itecture. However, many of these advantages apply equally to \nother high-level languages. So why has C su cceeded where so many other languages have \nlargely failed?  \nPerhaps the greatest strength of C- and the thing that sets it ap art from languages like Pascal \nand FORTRAN-is that it is a very \"low-lev el\" high-level language. As we shall see \nthroughout the book, C gives embedded programmers  an extraordinary degree of direct \nhardware control without sacrif icing the benefits of high-le vel languages. The \"low-level\" \nnature of C was a clear intention of the langua ge's creators. In fact, Kernighan and Ritchie \nincluded the following comment in  the opening pages of their book The C Programming \nLanguage  :  \nProgramming Embedded Systems in C and C++ \n- 19 - C is a relatively \"low level\" language. This characterization is not pejorative; it simply means that C deals with \nthe same sort of objects that most  computers do. These may be combined  and moved about with the arithmetic \nand logical operators implem ented by real machines.  \nFew popular high-level languages can compete with C in the production of compact, effi cient code for almost all \nprocessors. And, of these, only C allows programmers to interact with the underlying hardware so easily.  \n1.3.1 Other Embedded Languages  \nOf course, C is not the only language used by embedded programmers. At least three other \nlanguages-assembly, C++, and Ada-are wo rth mentioning in greater detail.  \nIn the early days, embedded software was written  exclusively in the a ssembly language of the \ntarget processor. This gave programmers co mplete control of the processor and other \nhardware, but at a price. Assembly languages ha ve many disadvantages, not the least of which \nare higher software development costs and a lack of code portabili ty. In addition, finding \nskilled assembly programmers has become much more difficult in recent years. Assembly is \nnow used primarily as an adjunct to the high -level language, usually  only for those small \npieces of code that must be extremely efficien t or ultra-compact, or cannot be written in any \nother way.  \nC++ is an object-oriented superset of C that is increasingly popular among embedded \nprogrammers. All of the core language features are the same  as C, but C++ adds new \nfunctionality for better data abstraction and a more object- oriented style of programming. \nThese new features are very helpful to softwa re developers, but some of them do reduce the \nefficiency of the executable program. So C++ tends to be most popular with large \ndevelopment teams, where the benefits to develo pers outweigh the loss of program efficiency.  \nAda is also an object-oriented  language, though it is substantially  different than C++. Ada was \noriginally designed by the U.S. Department of Defense for the development of mission-critical military software. Despite bei ng twice accepted as an international standard \n(Ada83 and Ada95), it has not gained much of a foothold outside of the defense and \naerospace industries. And it is lo sing ground there in recent years.  This is unfortunate because \nthe Ada language has many features that woul d simplify embedded software development if \nused instead of C++.  \n1.3.2 Choosing a Language for the Book  \nA major question facing the author of a book like this is, which programming languages \nshould be included in the disc ussion? Attempting to cover to o many languages might confuse \nthe reader or detract from mo re important points. On the other hand, focusing too narrowly \ncould make the discussion unnecessarily academic or (worse for the author and publisher) \nlimit the potential market for the book.  \nProgramming Embedded Systems in C and C++ \n- 20 - Certainly, C must be the cen terpiece of any book about em bedded programming-and this \nbook will be no exception. More than half of th e sample code is written in C, and the \ndiscussion will focus primarily on C-related progra mming issues. Of course, everything that is \nsaid about C programming applies equally to C++.  In addition, I will cover those features of \nC++ that are most useful for embedded softwa re development and us e them in the later \nexamples. Assembly language will be discussed in certain limited contexts, but will be avoided whenever possible. In other words, I will mention assembly language only when a \nparticular programming task cannot be accomplished in any other way.  \nI feel that this mixed treatment of C, C++,  and assembly most accurately reflects how \nembedded software is actually developed today and how it will continue to be developed in \nthe near-term future. I hope that this choi ce will keep the discussion clear, provide \ninformation that is useful to people developing ac tual systems, and include as large a potential \naudience as possible.  \n1.4 A Few Words About Hardware \nIt is the nature of programming that books about the subjec t must include examples. Typically, \nthese examples are selected so that they can be easily experimented with by interested readers. \nThat means readers must have access to the very same software development tools and \nhardware platforms used by the author. Unfort unately, in the case of  embedded programming, \nthis is unrealistic. It simply  does not make sense to run any of the example programs on the \nplatforms available to most readers-PCs, Macs, and Unix workstations.  \nEven selecting a standard embedded platform is difficult. As you have already learned, there \nis no such thing as a \"typical\" embedded system. Whatever hardware is selected, the majority \nof readers will not have access to it. But despite this rather significant problem, I do feel it is \nimportant to select a reference hardware platfo rm for use in the examples. In so doing, I hope \nto make the examples consistent and, t hus, the entire discussion more clear.  \nIn order to illustrate as many points as possible with a single piece of hardware, I have found \nit necessary to select a middle-of-the-road pl atform. This hardware consists of a 16-bit \nprocessor (Intel's 80188EB[2] ), a decent amount of memory  (128KB of RAM and 256 KB of \nROM), and some common types of inputs, outpu ts, and peripheral components. The board \nI've chosen is called the Target188EB and is manufactured and sold by Arcom Control \nSystems. More information about the Arcom boar d and instructions for obtaining one can be \nfound in Appendix A .  \n[2] Intel's 80188EB processor is a special version of the 80186 th at has been redesigned for use in embedded systems. The origina l \n80186 was a successor to the 8086 processor that IBM used in th eir very first personal computer-the PC/XT. The 80186 was never  \nthe basis of any PC because it was passed over (in favor of the  80286) when IBM designed their next model-the PC/AT. Despite \nthat early failure, versions of the 80186 from Intel and AMD ha ve enjoyed tremendous success in embedded systems in recent \nyears. \nProgramming Embedded Systems in C and C++ \n- 21 - If you have access to the reference hardware, you will be able to work through the examples \nin the book exactly as they are presented. Otherw ise, you will need to port the example code \nto an embedded platform that you do have access  to. Toward that end, every effort has been \nmade to make the example programs as portable as  possible. However, the reader should bear \nin mind that the hardware in each embedded system  is different and that some of the examples \nmight be meaningless on his hardware. For exampl e, it wouldn't make sense to port the Flash \nmemory driver presented in",
    "Chapter 2": ") to read and write the \nregisters of an I/O-mapped device.  \n7.2 The Device Driver Philosophy \nProgramming Embedded Systems in C and C++ \n- 95 - When it comes to designing device drivers, you should always focus on one easily stated goal: \nhide the hardware completely. When you're fini shed, you want the device driver module to be \nthe only piece of software in the entire system that reads or writes that particular device's \ncontrol and status registers di rectly. In addition, if the devi ce generates any interrupts, the \ninterrupt service routine that res ponds to them should be an integr al part of the device driver. \nIn this section, I'll explain why I recommend this philosophy and how it can be achieved.  \nOf course, attempts to hide the hardware comp letely are difficult. Any programming interface \nyou select will reflect the broad f eatures of the device. That's to be expected. The goal should \nbe to create a programming interface that woul d not need to be changed if the underlying \nperipheral were replaced with another in its general class. For example, all Flash memory \ndevices share the concepts of sectors (though the sector size can differ between chips). An \nerase operation can be performed only on an enti re sector, and once eras ed, individual bytes \nor words can be rewritten. So the programm ing interface provided by the Flash driver \nexample in the last",
    "Chapter 3": ". In case you don't remember, its job is to the prepare the way for \ncode written in a high-level language. Of importa nce here is only that the startup code calls \nmain . From that point forward, al l of your other software can be written in C or C++.  \nHopefully, you are starting to unde rstand how embedded software gets from processor reset to \nyour main program. Admittedly, the very first time you try to pull all of these components \ntogether (reset code, hardware initialization, C/C++ startup code, and application) on a new \nboard there will be problems. So expect to  spend some time debugging each of them. \nHonestly, this will be the hardest part of th e project. You will soon see that once you have a \nworking Blinking LED program to fall back on, the work just gets easier and easier-or at least \nmore similar to ordinary  computer programming.  \nUp to this point in the book we have b een building the infras tructure for embedded \nprogramming. But the topics we're going to talk  about in the remaining chapters concern \nhigher-level structures: memory tests, device drivers, operating systems, and actually useful \nprograms. These are pieces of software you' ve probably seen before on other computer \nsystems projects. However, there will still be  some new twists related to the embedded \nprogramming environment.  \nProgramming Embedded Systems in C and C++ \n- 64 -",
    "Chapter 4": ". Downloading and Debugging \nI can remember the exact instant when I realized  that a large part of my  life from then on was \ngoing to be spent in finding mi stakes in my own programs.  \n-Maurice Wilkes, Head of the Computer Laboratory of the University of Cambridge, 1949  \nOnce you have an executable binary image stored as a file on the host computer, you will \nneed a way to download that image to the em bedded system and execute it. The executable \nbinary image is usually loaded into a memory  device on the target bo ard and executed from \nthere. And if you have the right t ools at your disposal, it  will be possible to set breakpoints in \nthe program or to observe its execution in less intrusive ways. This",
    "Chapter 5": ", contains three obvious software tasks:  \nTask 1: Receive data from the computer attached to serial port A. \nTask 2: Receive data from the computer attached to serial port B. \nTask 3: Format and send the waiting data (if any)  to the printer attached to the parallel port.  \nTasks provide a key software abstraction th at makes the design and implementation of \nembedded software easier and the resulting sour ce code simpler to understand and maintain. \nBy breaking the larger program up into sma ller pieces, the programmer can more easily \nconcentrate her energy and talents on the unique features of the system under development.  \nStrictly speaking, an operati ng system is not a required component of any computer \nsystem-embedded or otherwise. It is always possible to perform the same functions from \nwithin the application program itself. Indeed, a ll of the examples so far in this book have done \njust that. There is simply one  path of execution-starting at main - that is downloaded into the \nProgramming Embedded Systems in C and C++ \n- 110 - system and run. This is the equivalent of havi ng only one task. But as the complexity of the \napplication expands beyond just  blinking an LED, the benefits  of an operating system far \noutweigh the associated costs.  \nIf you have never worked on operating system internals before, you might have the \nimpression that they are complex. I'm sure th e operating system vendors would like you to \ncontinue to believe that they are and that only a handful of computer sc ientists are capable of \nwriting one. But I'm here to let the cat out of th e bag: it's not all that hard! In fact, embedded \noperating systems are even easier to write than their desktop cousins-the required \nfunctionality is smaller and bette r defined. Once you learn what th at functionality is and a few \nimplementation techniques, you will see that an op erating system is no harder to develop than \nany other piece of embedded software.  \nEmbedded operating systems are small because they lack many of the things you would \nexpect to find on your desktop computer. For ex ample, embedded systems rarely have disk \ndrives or graphical displays, and hence they n eed no filesystem or gra phical user interface in \ntheir operating systems. In additi on, there is only one \"user\" (i.e., all of the tasks that comprise \nthe embedded software cooperate), so the secur ity features of multiuser operating systems do \nnot apply. All of these are featur es that could be part of an embedded operating system but are \nunnecessary in the majority of cases.  \n8.2 A Decent Embedded Operating System \nWhat follows is a description of an embedded operating system that I have developed on my \nown. I call my operating system ADEOS (pronounc ed the same as the Spanish farewell), \nwhich is an acronym for \"A Decent Embedded Oper ating System.\" I think that name really \nsums it up nicely. Yes, it is an embedded operatin g system; but it is neither the best nor the \nworst in any regard. In all, there are less th an 1000 lines of source code. Of these, three \nquarters are platform-independent and written  in C++. The rest are hardware- or \nprocessor-specific and, therefore, written in assembly language. In  the discussion later, I will \npresent and explain all of the r outines that are written in C++ along with the theory you need \nto understand them. In the interest of clarit y, I will not present the source code for the \nassembly language routines. Instead, I will si mply state their purpose and assume that \ninterested readers will download a nd examine that code on their own.  \nIf you would like to use ADEOS (or a modified  version of it) in your embedded system, \nplease feel free to do so. In fact, I would very much like to hear from anyone who uses it. I \nhave made every effort to test the code and improve upon the weaknesses I have uncovered. \nHowever, I can make no guarantee that the code presented in this chap ter is useful for any \npurpose other than learning about operating systems. If you decide  to use it anyway, please be \nprepared to spend some amount of your time finding and fixing bugs in the operating system \nitself.  \nProgramming Embedded Systems in C and C++ \n- 111 - 8.2.1 Tasks  \nWe have already talked about multitasking a nd the idea that an ope rating system makes it \npossible to execute multiple \"programs\" at the same time. But what does that mean? How is it \npossible to execute several task s concurrently? In act uality, the tasks are not executed at the \nsame time. Rather, they are executed in pse udoparallel. They merely  take turns using the \nprocessor. This is similar to the way several people might read the same copy of a book. Only one person can actually use the book at a given moment, but they can both read it by taking \nturns using it.  \nAn operating system is responsible for deciding which task gets to us e the processor at a \nparticular moment. In addition, it maintains in formation about the state of each task. This \ninformation is called the task's context, and it  serves a purpose similar to a bookmark. In the \nmultiple book reader scenario, each reader is presumed to have her own bookmark. The \nbookmark's owner must be able to recognize it (e .g., it has her name written on it), and it must \nindicate where she stopped reading when last  she gave up control of the book. This is the \nreader's context.  \nA task's context records the state of the processo r just prior to another task's taking control of \nit. This usually consists of a pointer to the next instruction to be executed (the instruction \npointer), the address of the curren t top of the stack (the stack poi nter), and the contents of the \nprocessor's flag and general- purpose registers. On 16-bit 80x86 processors, these are the \nregisters CS and IP, SS and SP, Flags, and DS, ES, SI, DI, AX, BX, CX, and DX, \nrespectively.  \nIn order to keep tasks and th eir contexts organized, the operating system maintains a bit of \ninformation about each task. Operating systems wr itten in C often keep this information in a \ndata structure called the task control block. Ho wever, ADEOS is written in C++ and one of \nthe advantages of this approach is that the task -specific data is automa tically made a part of \nthe task object itself. The definition of a Task , which includes the information that the \noperating system needs, is as follows:  \nclass Task \n{     public:            Task(void (*function)(), Priority p, int stackSize);          TaskId         id;         Context        context;         TaskState      state;         Priority       priority;         int *          pStack;         Task *         pNext; \nProgramming Embedded Systems in C and C++ \n- 112 -  \n        void  (*entryPoint)();      private:          static TaskId  nextId; };\n \nMany of the data members of this class will make sense only after we discuss the operating \nsystem in greater detail. Ho wever, the first two fields- id and context  --should already sound \nfamiliar. The id contains a unique integer (between and 255) that identifies the task. In other \nwords, it is the name on the bookmark. The context  is the processor-specific data structure \nthat actually contains the state of the processo r the last time this task gave up control of the \nprocessor.  \n8.2.1.1 Task states  \nRemember how I said that only one task could ac tually be using the proc essor at a given time? \nThat task is said to be the \" running\" task, and no other task ca n be in that same state at the \nsame time. Tasks that are ready to run-but ar e not currently using th e processor-are in the \n\"ready\" state, and tasks that are waiting for some event external to themselves to occur before \ngoing on are in the \"waiting\" state. Figure 8-1  shows the relationships between these three \nstates.  \nFigure 8-1. Possible states of a task  \n \nA transition between the ready and running states occurs wh enever the operating system \nselects a new task to run. The task that was previously running becomes ready, and the new \ntask (selected from the pool of tasks in the ready state) is pr omoted to running. Once it is \nrunning, a task will leave that stat e only if it is forced to do so  by the operating system or if it \nneeds to wait for some event external to itself  to occur before continuing. In the latter case, \nthe task is said to block, or wait, until that  event occurs. And when that happens, the task \nenters the waiting state and the operating system selects one of the ready tasks to be run. So, \nalthough there may be any number of tasks in ea ch of the ready and waiting states, there will \nnever be more (or less) than one task  in the running state at any time.  \nProgramming Embedded Systems in C and C++ \n- 113 - Here's how a task's state is actually defined in ADEOS: \nenum TaskState { Ready, Running, Waiting };  \nIt is important to note that onl y the scheduler-the part of the operating system that decides \nwhich task to run-can promote a task to the r unning state. Newly created tasks and tasks that \nare finished waiting for their external event are placed into the ready state first. The scheduler \nwill then include these new ready tasks in its future decision-making.  \n8.2.1.2 Task mechanics  \nAs an application developer working with ADEOS (or any other operating system), you will \nneed to know how to create and use tasks. Like any other abstra ct data type, the Task  class \nhas its own set of routines to do just that. Ho wever, the task interface in ADEOS is simpler \nthan most because you can do nothing but create new Task  objects. Once created, an ADEOS \ntask will continue to exist in the system until the associated function returns. Of course, that \nmight not happen at all, but if it does, the task will be deleted automatically by the operating \nsystem.  \nThe Task  constructor is shown below.  The caller assigns a function, a priority, and an optional \nstack size to the new task by way of the cons tructor's parameters. The first parameter, \nfunction , is a pointer to the C/C++ or assembly language function that is to be executed \nwithin the context of the new task. The only requir ements for this function are that it take no \narguments and return nothing. The second parameter, p, is a unique number from 1 to 255 that \nrepresents the new task's priority relative to other tasks in the system. These numbers are used \nby the scheduler when it is selecting the next task to be run (higher numbers represent higher \npriorities).  \nTaskId    Task::nextId = 0; \n /**********************************************************************  *  * Method:      Task()  *  * Description: Create a new task and initialize its state.  *  * Notes:  *   * Returns:       *  **********************************************************************/ Task::Task(void (*function)(), Priority p, int stackSize) {     stackSize /= sizeof(int);               // Convert bytes to words. \nProgramming Embedded Systems in C and C++ \n- 114 -  \n    enterCS();                          ////// Critical Section Begin      //      // Initialize the task-specific data.     //     id         = Task::nextId++;     state      = Ready;     priority   = p;             entryPoint = function;     pStack     = new int[stackSize];     pNext      = NULL;      //     // Initialize the processor context.     //     contextInit(&context, run, this, pStack + stackSize);          //     // Insert the task into the ready list.     //     os.readyList.insert(this);         os.schedule();                          // Scheduling Point          exitCS();                           ////// Critical Section End  }   /* Task() */\n \nNotice how the functional part of this rou tine is surrounded by the two function calls enterCS  \nand exitCS . The block of code between these calls is said to be a critical section . A critical \nsection is a part of a program that must be exec uted atomically. That is, the instructions that \nmake up that part must be executed in order and without interruption. Because an interrupt \ncan occur at any time, the only way to make su ch a guarantee is to di sable interrupts for the \nduration of the critical section. So enterCS  is called at the beginning of  the critical section to \nsave the interrupt enable state a nd disable further interrupts. And exitCS  is called at the end to \nrestore the previously saved interrupt state. We  will see this same technique used in each of \nthe routines that follow.  \nThere are several other routines that I've called from the construc tor in the previous code, but \nI don't have the space to list here. These are the routines contextInit  and os.readyList.insert . \nThe contextInit  routine establishes the in itial context for a task. Th is routine is necessarily \nprocessor-specific and, therefore, written in assembly language.  \nProgramming Embedded Systems in C and C++ \n- 115 - contextInit  has four parameters. The first is a pointer to  the context data structure that is to be \ninitialized. The second is a pointer to the star tup function. This is a special ADEOS function, \ncalled run, that is used to start a task and clean up  behind it if the associated function later \nexits. The third parameter is a pointer to the new Task  object. This parameter is passed to run \nso the function associated with the task can be  started. The fourth and final parameter is a \npointer to the new task's stack.  \nThe other function call is to os.readyList.insert . This call adds the new task to the operating \nsystem's internal list of ready tasks. The readyList  is an object of type TaskList . This class \nis just a linked list of tasks (order ed by priority) that has two methods: insert  and remove . \nInterested readers should downl oad and examine the source code for ADEOS if they want to \nsee the actual implementation of these functions. You'll also lear n more about the ready list in \nthe discussion that follows.  \nApplication Progra mming Interfaces \nOne of the most annoying things about embe dded operating systems is their lack of \na common API. This is a particular probl em for companies that want to share \napplication code between products that are based on different operating systems. \nOne company I worked for even went so fa r as to create thei r own layer above the \noperating system solely to isolate thei r application programmers from these \ndifferences. But surely this was just a dding to the overall problem-by creating yet \nanother API.  \nThe basic functionality of every embedded operating system is much the same. Each \nfunction or method represents a service th at the operating system can perform for \nthe application program. But there aren't th at many different services possible. And \nit is frequently the case that the only real  difference between two implementations is \nthe name of the function or method.  \nThis problem has persisted for several decad es, and there is no end in sight. Yet \nduring that same time the Win32 and POSI X APIs have taken hold on PCs and Unix \nworkstations, respectively. So why hasn't a similar standard emerged for embedded systems? It hasn't been for a lack of tryi ng. In fact, the authors of the original POSIX \nstandard (IEEE 1003.1) also created a st andard for real-time systems (IEEE \n1003.4b). And a few of the more Unix-lik e embedded operating systems (VxWorks \nand LynxOS come to mind) are compliant with  this standard API. However, for the \nvast majority of application programmers, it is necessary to learn a new API for each \noperating system used.  \nFortunately, there is a glimmer of ho pe. The Java programming language has \nsupport for multitasking and task synchronization built in. That means that no matter what operating system a Java program is running on, the mechanics of creating and \nmanipulating tasks and synchronizing their activities remain the same. For this and \nProgramming Embedded Systems in C and C++ \n- 116 - several other reasons, Java would be a very nice language for embedded \nprogrammers. I hope that there will some  day be a need for a book about embedded \nsystems programming in Java and that a si debar like this one will, therefore, no \nlonger be required.  \n8.2.2 Scheduler  \nThe heart and soul of any operating system is its  scheduler. This is the piece of the operating \nsystem that decides which of the ready tasks has the right to use the processor at a given time. \nIf you've written software for a mainstream ope rating system, then you might be familiar with \nsome of the more common scheduling algorithms: first-in-first-out, shor test job first, and \nround robin. These are simple sc heduling algorithms that are us ed in nonembedded systems.  \nFirst-in-first-out (FIFO) sche duling describes an operating sy stem like DOS, which is not a \nmultitasking operating system at all. Rather, each  task runs until it is finished, and only after \nthat is the next task started. However, in DOS  a task can suspend itself, thus freeing up the \nprocessor for the next task. And that's precise ly how older version of  the Windows operating \nsystem permitted users to switch from one task to another. True multitasking wasn't a part of \nany Microsoft operating syst em before Windows NT.  \nShortest job first describes a similar schedul ing algorithm. The only di fference is that each \ntime the running task completes or suspends itself , the next task selected is the one that will \nrequire the least amount of processor time to  complete. Shortest job first was common on \nearly mainframe systems because it has the appe aling property of maximizing the number of \nsatisfied customers. (Only the customers w ho have the longest jobs tend to notice or \ncomplain.)  \nRound robin is the only scheduling algorithm of the three in which the running task can be \npreempted, that is, interrupted while it is running. In this cas e, each task runs for some \npredetermined amount of time. After that tim e interval has elapsed, the running task is \npreempted by the operating system and the next task in line gets its chance to run. The \npreempted task doesn't get to run again until all of the other tasks have had their chances in \nthat round.  \nUnfortunately, embedded operating systems cannot use any of these simplistic scheduling \nalgorithms. Embedded systems (particularly real- time systems) almost always require a way \nto share the processor that allows the most impor tant tasks to grab cont rol of the processor as \nsoon as they need it. Therefore, most embedded operating systems utilize a priority-based scheduling algorithm that supports preemption. This  is a fancy way of saying that at any given \nmoment the task that is currently using the pr ocessor is guaranteed to be the highest-priority \ntask that is ready to do so. Lower-priority tasks must wait until higher-priority tasks are \nfinished using the processor before resuming their work. The word preemptive adds that any running task can be interrupted by the operating system if a task  of higher priority becomes \nProgramming Embedded Systems in C and C++ \n- 117 - ready. The scheduler detects such conditions at a finite set of time instants called scheduling \npoints.  \nWhen a priority-based scheduling algorithm is used, it is also necessa ry to have a backup \npolicy. This is the scheduling algor ithm to be used in the event that several ready tasks have \nthe same priority. The most common backup sc heduling algorithm is round robin. However, \nfor simplicity's sake, I've implemented only a FIFO scheduler for my backup policy. For that \nreason, users of ADEOS should take  care to assign a unique prio rity to each task whenever \npossible. This shouldn't be a problem though, because ADEOS supports as many priority \nlevels as tasks (up to 255 of each).  \nThe scheduler in ADEOS is implemented in a class called Sched :  \nclass Sched \n{     public:          Sched();          void  start();         void  schedule();          void  enterIsr();         void  exitIsr();          static Task *    pRunningTask;         static TaskList  readyList;           enum SchedState { Uninitialized, Initialized, Started };      private:          static SchedState  state;         static Task        idleTask;         static int         interruptLevel;         static int         bSchedule; };\n \nAfter defining this class, an object of this t ype is instantiated with in one of the operating \nsystem modules. That way, users of ADEOS need only link the file sched.obj  to include an \ninstance of the scheduler. This instance is called os and is declared as follows:  \nextern Sched os;  \nProgramming Embedded Systems in C and C++ \n- 118 - References to this global variable can be ma de from within any pa rt of the application \nprogram. But you'll soon see that only one such re ference will be necessary per application.  \n8.2.2.1 Scheduling points  \nSimply stated, the scheduling points are the set of operating system events that result in an \ninvocation of the scheduler. We have already en countered two such events: task creation and \ntask deletion. During each of  these events, the method os.schedule  is called to select the next \ntask to be run. If the currently executing task sti ll has the highest priority of all the ready tasks, \nit will be allowed to continue using the processo r. Otherwise, the highest priority ready task \nwill be executed next. Of course, in the case of task deletion a new task is always selected: the \ncurrently running task is  no longer ready, by virtue of the fact that it no longer exists!  \nA third scheduling point is calle d the clock tick. The clock tick is a periodic event that is \ntriggered by a timer interrupt. The clock tick prov ides an opportunity to awake tasks that are \nwaiting for a software timer to expire. This is almost exactly the same as the timer tick we saw in the previous chapter. In fact, suppor t for software timers is a common feature of \nembedded operating systems. During the clock tick, the operating system decrements and \nchecks each of the active software timers. When  a timer expires, all of the tasks that are \nwaiting for it to complete are changed from th e waiting state to the ready state. Then the \nscheduler is invoked to see if one of these newly awakened tasks has a higher priority than the \ntask that was running prior to the timer interrupt.  \nThe clock tick routine in ADEOS is almost exactly the same as the one in",
    "Chapter 6": ". Memory \nTyrell:  If we give them a past, we create a cushion for th eir emotions and, consequently, we can control them \nbetter.  \nDeckard : Memories. You're talking about memories.  \n-the movie Blade Runner  \nIn this chapter, you will learn everything you need to know about memory in embedded \nsystems. In particular, you will learn about th e types of memory you ar e likely to encounter, \nhow to test memory devices to see if they  are working properly, and how to use Flash \nmemory.  \n6.1 Types of Memory \nMany types of memory devices are available fo r use in modern computer systems. As an \nembedded software engineer, you must be aware of the differences between them and understand how to use each type effectively. In our discussion, we will approach these \ndevices from a software viewpoint. As you ar e reading, try to keep in mind that the \ndevelopment of these devices took several decad es and that there are significant physical \ndifferences in the underlying hardware. The names of the memory types frequently reflect the \nhistorical nature of the development process a nd are often more confusing than insightful.  \nMost software developers think of memory  as being either random-access (RAM) or \nread-only (ROM). But, in fact, there are subt ypes of each and even a third class of hybrid \nmemories. In a RAM device, the data stored at each memory location can  be read or written, \nas desired. In a ROM device, the data stored at each memory location can be read at will, but \nnever written. In some cases, it is possible to  overwrite the data in a ROM-like device. Such \ndevices are called hybrid memories because they exhibit some of the ch aracteristics of both \nRAM and ROM. \nFigure 6-1  provides a classification system for the memory devices that are \ncommonly found in embedded systems.  \nProgramming Embedded Systems in C and C++ \n- 65 - Figure 6-1. Common memory types in embedded systems  \n \n6.1.1 Types of RAM  \nThere are two important memory devices in the RAM family: SRAM and DRAM. The main \ndifference between them is the lifetime of the data stored. SRAM (static RAM) retains its \ncontents as long as electrical power is applied to  the chip. However, if the power is turned off \nor lost temporarily then its contents will be lost forever. DRAM (dynamic RAM), on the other \nhand, has an extremely short data lifetime-usually less than a quarter of a second. This is true \neven when power is applied constantly.  \nIn short, SRAM has all the properties of th e memory you think of when you hear the word \nRAM. Compared to that, DRAM sounds kind of useless. What good is a memory device that \nretains its contents for only a fraction of a sec ond? By itself, such a vol atile memory is indeed \nworthless. However, a simple piece of hardware called a DRAM controller can be used to make DRAM behave more like SRAM. (See \nDRAM Controllers  later in this chapter.) The job of \nthe DRAM controller is to periodically refresh the data stored in the DRAM. By refreshing \nthe data several times a second, the DRAM contro ller keeps the contents  of memory alive for \nas long as they are needed. So, DRAM is as useful as SRAM after all.  \nDRAM Controllers \nIf your embedded system includes DRAM, th ere is probably a DRAM controller on \nboard (or on-chip) as well. The DRAM c ontroller is an extra piece of hardware \nplaced between the processor and the memory  chips. Its main purpose is to perform \nthe refresh operations required to keep your data alive in the DRAM. However, it \ncannot do this properly without some help from you.  \nOne of the first things your software must  do is initialize the DRAM controller. If \nyou do not have any other RAM in the syst em, you must do this before creating the \nstack or heap. As a result, this initializa tion code is usually written in assembly \nProgramming Embedded Systems in C and C++ \n- 66 - language and placed within the hardware initialization module.  \nAlmost all DRAM controllers require a shor t initialization sequence that consists of \none or more setup commands. The setup co mmands tell the controller about the \nhardware interface to the DRAM and how frequently the data there must be \nrefreshed. To determine the initializati on sequence for your particular system, \nconsult the designer of the boa rd or read the databooks th at describe the DRAM and \nDRAM controller. If the DRAM in your system does not appear to be working \nproperly, it could be that the DRAM controller either is not  initialized or has been \ninitialized incorrectly.  \nWhen deciding which type of RAM to use, a system designer must consider access time and \ncost. SRAM devices offer extremely fast access times (approximately four times faster than \nDRAM) but are much more expensive to pr oduce. Generally, SRAM is used only where \naccess speed is extremely important. A lower cost per byte makes DRAM attractive whenever large amounts of RAM are required. Many em bedded systems include both types: a small \nblock of SRAM (a few hundred kilobytes) along a critical data path and a much larger block \nof DRAM (in the megabytes ) for everything else.  \n6.1.2 Types of ROM  \nMemories in the ROM family are distinguished by the methods used to write new data to \nthem (usually called programming) and the num ber of times they can be rewritten. This \nclassification reflects the evolution of RO M devices from hardwired to one-time \nprogrammable to erasable-and-programmable. A common feature across all these devices is \ntheir ability to retain data and programs forever, even during a power failure.  \nThe very first ROMs were hardwired devices that  contained a preprogrammed set of data or \ninstructions. The contents of the ROM had to  be specified before chip production, so the \nactual data could be used to arrange the transi stors inside the chip! Hardwired memories are \nstill used, though they are now called \"masked RO Ms\" to distinguish them from other types \nof ROM. The main advantage of a masked RO M is a low production cost. Unfortunately, the \ncost is low only when hundreds of thousands of  copies of the same ROM are required.  \nOne step up from the masked ROM is the PR OM (programmable ROM), which is purchased \nin an unprogrammed state. If you were to l ook at the contents of an unprogrammed PROM, \nyou would see that the data is made up entirely of  1's. The process of writing your data to the \nPROM involves a special piece of equipmen t called a device programmer. The device \nprogrammer writes data to the device one word at  a time, by applying an electrical charge to \nthe input pins of the chip. Once a PROM has be en programmed in this way, its contents can \nnever be changed. If the code or  data stored in the PROM must  be changed, the current device \nmust be discarded. As a result, PROMs are also known as one-time programmable  (OTP) \ndevices.  \nProgramming Embedded Systems in C and C++ \n- 67 - An EPROM (erasable-and-programmable ROM) is  programmed in exactly the same manner \nas a PROM. However, EPROMs can be erased and reprogrammed repeatedly. To erase an EPROM, you simply expose the device to a stro ng source of ultraviolet light. (There is a \n\"window\" in the top of the device to let the ultraviolet light re ach the silicon.) By doing this, \nyou essentially reset the entire chip to its initial-unprogramme d-state. Though more expensive \nthan PROMs, their ability to be reprogramm ed makes EPROMs an e ssential part of the \nsoftware development and testing process.  \n6.1.3 Hybrid Types  \nAs memory technology has matured in recent years, the line between RAM and ROM devices \nhas blurred. There are now severa l types of memory that combin e the best features of both. \nThese devices do not belong to either group a nd can be collectively referred to as hybrid \nmemory devices. Hybrid memories can be r ead and written as desired, like RAM, but \nmaintain their contents without electrical pow er, just like ROM. Two of the hybrid devices, \nEEPROM and Flash, are descendants of ROM devices; the third, NVRAM, is a modified \nversion of SRAM.  \nEEPROMs are electrically-erasabl e-and-programmable. Internal ly, they are similar to \nEPROMs, but the erase operation is accomplished electrically, rather than by exposure to \nultraviolet light. Any byte within an EEPROM ca n be erased and rewritten. Once written, the \nnew data will remain in the device forever-or  at least until it is electrically erased. The \ntradeoff for this improved functionality is ma inly higher cost. Write cycles are also \nsignificantly longer than writes to a RAM, so you wouldn't want to use an EEPROM for your \nmain system memory.  \nFlash memory is the most recent advancement in memory technology. It combines all the best \nfeatures of the memory devices described thus  far. Flash memory devices are high density, \nlow cost, nonvolatile, fast (to read, but not to write), and electrically  reprogrammable. These \nadvantages are overwhelming and the use of Fl ash memory has increased dramatically in \nembedded systems as a direct result. From  a software viewpoint, Flash and EEPROM \ntechnologies are very similar. The major differe nce is that Flash devices can be erased only \none sector at a time, not byte by byte. Typical se ctor sizes are in the range of 256 bytes to 16 \nkilobytes. Despite this disadvantage, Flash is much more popular than EEPROM and is \nrapidly displacing many of the ROM devices as well.  \nThe third member of the hybrid memory cl ass is NVRAM (nonvolatile RAM). Nonvolatility \nis also a characteristic of the ROM and hybrid  memories discussed earlier. However, an \nNVRAM is physically very different from t hose devices. An NVRAM is usually just an \nSRAM with a battery backup. When the power is turned on, the NVRAM operates just like \nany other SRAM. But when the power is turned off, the NVRAM draws just enough electrical \npower from the battery to retain its current contents. NVRAM is fairly common in embedded \nsystems. However, it is very expensive-even more expensive than SR AM-so its applications \nProgramming Embedded Systems in C and C++ \n- 68 - are typically limited to the storage of only a fe w hundred bytes of system -critical information \nthat cannot be stored in any better way.  \nTable 6-1  summarizes the characteristics of different memory types.  \nTable 6-1. Memory Devi ce Characteristics  \nMemory \nType Volatile? Writeable? Erase \nSize Erase Cycles Relative Cost Relative Speed \nSRAM yes yes byte unlimited expensive fast \nDRAM yes yes byte unlimited moderate moderate \nMasked \nROM no no n/a n/a inexpensive fast \nPROM no once, with \nprogrammer n/a n/a moderate fast \nEPROM no yes, with \nprogrammer entire \nchip limited (see \nspecs) moderate fast \nEEPROM no yes byte limited (see \nspecs) expensive fast to read, slow \nto write \nFlash no yes sector limited (see \nspecs) moderate fast to read, slow \nto write \nNVRAM no yes byte none expensive fast \n6.2 Memory Testing \nOne of the first pieces of serious embedded softwa re you are likely to write is a memory test. \nOnce the prototype hardware is ready, the designer would like some reassurance that she has \nwired the address and data lines correctly and that the memory chips are working properly. At \nfirst this might seem like a fairly simple as signment, but as you look at the problem more \nclosely you will realize that it can  be difficult to detect subtle memory problems with a simple \ntest. In fact, as a result of programmer naiveté, many embedded systems include memory tests \nthat would detect only the most catastrophic memo ry failures. Some of these might not even \nnotice that the memory chips have been removed from the board!  \nDirect Memory Access \nDirect memory access (DMA) is a technique fo r transferring blocks of data directly \nbetween two hardware devices. In the absen ce of DMA, the processor must read the \ndata from one device and write  it to the other, one byte or  word at a time. If the \nProgramming Embedded Systems in C and C++ \n- 69 - amount of data to be transferred is large,  or the frequency of transfers is high, the \nrest of the software might never get a ch ance to run. However, if a DMA controller \nis present it is possible to have it perform the entire transfer, w ith little assistance \nfrom the processor.  \nHere's how DMA works. When a block of da ta needs to be tran sferred, the processor \nprovides the DMA controller with the source and destination addresses and the total \nnumber of bytes. The DMA controller then transfers the data from the source to the \ndestination automatically. After each byte is copied, each address is incremented and \nthe number of bytes remaining is redu ced by one. When the number of bytes \nremaining reaches zero, the block transfer  ends and the DMA controller sends an \ninterrupt to the processor.  \nIn a typical DMA scenario, the block of da ta is transferred directly to or from \nmemory. For example, a network controller might want to place an incoming network packet into memory as it arrive s, but only notify the processor once the \nentire packet has been received. By usi ng DMA, the processor can spend more time \nprocessing the data once it arrives and less time transferring it between devices. The \nprocessor and DMA controller must share the address and data buses during this \ntime, but this is handled automatically by the hardware and the processor is otherwise uninvolved with the actual transfer.  \nThe purpose of a memory test is  to confirm that each storage location in a memory device is \nworking. In other words, if you store the number 50 at a particular addr ess, you expect to find \nthat number stored there until another number is written. The basic idea behind any memory \ntest, then, is to write some set of data values to each address in the memory device and verify \nthe data by reading it back. If a ll the values read back are the sa me as those that were written, \nthen the memory device is said to pass the test. As you will see, it is only through careful \nselection of the set of data va lues that you can be sure that a passing result is meaningful.  \nOf course, a memory test like the one just descri bed is unavoidably destructive. In the process \nof testing the memory, you must overwrite it s prior contents. Because it is generally \nimpractical to overwrite the contents of nonvol atile memories, the tests described in this \nsection are generally used only for RAM tes ting. However, if the contents of a hybrid \nmemory are unimportant-as they are during the product development stage-these same \nalgorithms can be used to test those devices as well. The proble m of validating the contents of \na nonvolatile memory is addressed in a later section of this chapter.  \n6.2.1 Common Memory Problems  \nBefore learning about specific test algorithms , you should be familiar with the types of \nmemory problems that are likely to occu r. One common misconception among software \nengineers is that most memory problems occu r within the chips themselves. Though a major \nissue at one time (a few decades ago), problem s of this type are increasingly rare. The \nProgramming Embedded Systems in C and C++ \n- 70 - manufacturers of memory devices perform a va riety of post-production tests on each batch of \nchips. If there is a problem with a particular ba tch, it is extremely unlikely that one of the bad \nchips will make its way into your system.  \nThe one type of memory chip problem you could encounter is a catastrophic failure. This is \nusually caused by some sort of physical or el ectrical damage recei ved by the chip after \nmanufacture. Catastrophic failu res are uncommon and usually aff ect large portions of the chip. \nBecause a large area is a ffected, it is reasonable to assume that catastrophic failure will be \ndetected by any decent test algorithm.  \nIn my experience, a more common source of me mory problems is the circuit board. Typical \ncircuit board problems are:  \nProblems with the wiring between the processor and memory device \nMissing memory chips Improperly inserted memory chips These are the problems that a good memory test algorithm should be able to detect. Such a \ntest should also be able to detect catastrophi c memory failures without  specifically looking for \nthem. So let's discuss circuit board problems in more detail.  \n6.2.1.1 Electrical wiring problems  \nAn electrical wiring problem could be caused by an error in design or production of the board \nor as the result of damage received after ma nufacture. Each of the wires that connect the \nmemory device to the processor is one of three t ypes: an address line, a data line, or a control \nline. The address and data lines are used to sele ct the memory location and to transfer the data, \nrespectively. The control lines tell the memory device whether the processor wants to read or \nwrite the location and precisely when the data will be transferred. Unfortunately, one or more of these wires could be improperl y routed or damaged in such a way that it is either shorted \n(i.e., connected to another wire on the board) or open (not connected  to anything). These \nproblems are often caused by a bit of solder splash  or a broken trace, respectively. Both cases \nare illustrated in \nFigure 6-2 .  \nProgramming Embedded Systems in C and C++ \n- 71 - Figure 6-2. Possible wiring problems  \n \nProblems with the electrical connections to the processor will cause the memory device to \nbehave incorrectly. Data might be stored incorrectly, stored at the wrong address, or not \nstored at all. Each of these symptoms can  be explained by wiring problems on the data, \naddress, and control lines, respectively.  \nIf the problem is with a data li ne, several data bits might appear  to be \"stuck together\" (i.e., \ntwo or more bits always contain the same valu e, regardless of the data transmitted). Similarly, \na data bit might be either \"stu ck high\" (always 1) or \"stuck low\" (always 0). These problems \ncan be detected by writing a sequence of data valu es designed to test that  each data pin can be \nset to and 1, independently  of all the others.  \nIf an address line has a wiring problem, the conten ts of two memory locations might appear to \noverlap. In other words, data written to one address will instead overw rite the contents of \nanother address. This happens because an addres s bit that is shorted or open will cause the \nmemory device to see an address different from the one selected by the processor.  \nAnother possibility is that one of the control lines is shorted or open. Although it is \ntheoretically possible to develop specific tests for control line problems,  it is not possible to \ndescribe a general test for them. The operation of many control signals is specific to the \nprocessor or memory architecture.  Fortunately, if there is a pr oblem with a control line, the \nmemory will probably not work at all, and this will be detected by other memory tests. If you \nsuspect a problem with a control line, it is be st to seek the advice of the board's designer \nbefore constructing a specific test.  \n6.2.1.2 Missing memory chips  \nA missing memory chip is clearly a problem th at should be detected. Unfortunately, because \nof the capacitive nature of unconnected electrical  wires, some memory tests will not detect \nProgramming Embedded Systems in C and C++ \n- 72 - this problem. For example, suppose you decided to use the following test algorithm: write the \nvalue 1 to the first location in memory, verify  the value by reading it back, write 2 to the \nsecond location, verify the value, write 3 to the third location, verify, etc. Because each read \noccurs immediately after the corresponding write, it is possible that th e data read back \nrepresents nothing more than the voltage remain ing on the data bus from the previous write. If \nthe data is read back too quickly, it will appear  that the data has been correctly stored in \nmemory-even though there is no memory chip at the other end of the bus!  \nTo detect a missing memory chip, the test must be altered. Instead of performing the \nverification read immediately afte r the corresponding write, it is  desirable to perform several \nconsecutive writes followed by th e same number of consecutive reads. For example, write the \nvalue 1 to the first location, 2 to the second location, and 3 to the third location, then verify \nthe data at the first location, th e second location, etc. If  the data values are unique (as they are \nin the test just described), the missing chip wi ll be detected: the first value read back will \ncorrespond to the last value written (3 ), rather than the first (1).  \n6.2.1.3 Improperly inserted chips  \nIf a memory chip is present but improperly in serted in its socket, the system will usually \nbehave as though there is a wiri ng problem or a missing chip. In other words, some number of \nthe pins on the memory chip will either not be  connected to the sock et at all or will be \nconnected at the wrong place. These pins will be part of the data bus, address bus, or control \nwiring. So as long as you test for wiring proble ms and missing chips, any improperly inserted \nchips will be detected automatically.  \nBefore going on, let's quickly review the types of memory problems we must be able to detect. \nMemory chips only rarely have internal errors, but if they do, they ar e probably catastrophic \nin nature and will be detected by any test. A more common source of problems is the circuit board, where a wiring problem can occur or a memory chip might be missing or improperly \ninserted. Other memory problems can occur, but the ones described here are the most \ncommon and also the simplest to test in a generic way.  \n6.2.2 Developing a Test Strategy  \nBy carefully selecting your test  data and the order in which th e addresses are tested, it is \npossible to detect all of the memory problems de scribed earlier. It is usually best to break \nyour memory test into small, single-minded pieces. This helps to improve the efficiency of the \noverall test and the readability of the code. More specific tests can also provide more detailed \ninformation about the source of th e problem, if one is detected.  \nI have found it is best to have three individual memory tests: a data bus test, an address bus \ntest, and a device test. The first two test for electrical wiring problems and improperly \ninserted chips; the third is intended to detect  missing chips and catastr ophic failures. As an \nProgramming Embedded Systems in C and C++ \n- 73 - unintended consequence, the device test will also uncover problems with the control bus \nwiring, though it cannot provide useful informa tion about the source of such a problem.  \nThe order in which you execute th ese three tests is important. The proper order is: data bus \ntest first, followed by the addre ss bus test, and then the device test. That's because the address \nbus test assumes a working data bus, and the device test results are meaningless unless both \nthe address and data buses are known to be good. If  any of the tests fail, you should work with \na hardware engineer to locate the source of the problem. By looking at the data value or \naddress at which the test failed, she should be  able to quickly isolate the problem on the \ncircuit board.  \n6.2.2.1 Data bus test  \nThe first thing we want to test is the data bus wiring. We need to confirm that any value \nplaced on the data bus by the processor is co rrectly received by the memory device at the \nother end. The most obvious way to test that is to write  all possible data values and verify that \nthe memory device stores each one successfully. Ho wever, that is not the most efficient test \navailable. A faster method is to test the bus one bit at a time. The data bus passes the test if \neach data bit can be set to and 1, inde pendently of the other data bits.  \nA good way to test each bit independently is to  perform the so-called \"walking 1's test.\" Table \n6-2 shows the data patterns used in an 8-bit vers ion of this test. The name, walking 1's, comes \nfrom the fact that a single data bit is set to  1 and \"walked\" through th e entire data word. The \nnumber of data values to test is the same as the width of the data bus. This reduces the number \nof test patterns from 2n to n, wher e n is the width of the data bus.  \nTable 6-2. Consecutive Data Values for the Walking 1's Test  \n00000001 \n00000010 \n00000100 \n00001000 \n00010000 \n00100000 \n01000000 \n10000000 \nBecause we are testing only the data bus at this point, all of the data values can be written to \nthe same address. Any address within the memo ry device will do. However, if the data bus \nProgramming Embedded Systems in C and C++ \n- 74 - splits as it makes its way to more than one memory chip, you will need  to perform the data \nbus test at multiple addresses, one within each chip.  \nTo perform the walking 1's test, simply write th e first data value in the table, verify it by \nreading it back, write the second value, verify, etc. When you reach the end of the table, the \ntest is complete. It is okay to do the read immediately after the corresponding write this time \nbecause we are not yet looking for missing chips. In fact, this test may provide meaningful \nresults even if the memory chips are not installed!  \nThe function memTestDataBus  shows how to implement the walking 1's test in C. It assumes \nthat the caller will select the test address, and test s the entire set of data values at that address. \nIf the data bus is working properly, the function w ill return 0. Otherwise it will return the data \nvalue for which the test failed. The bit that is se t in the returned value corresponds to the first \nfaulty data line, if any.  \ntypedef unsigned char datum;     /* Set the data bus width to 8 bits. */ \n /**********************************************************************  *  * Function:    memTestDataBus()  *  * Description: Test the data bus wiring in a memory region by  *              performing a walking 1's test at a fixed address  *              within that region.  The address (and hence the  *              memory region) is selected by the caller.  *  * Notes:         *  * Returns:     0 if the test succeeds.    *              A nonzero result is the first pattern that failed.  *  **********************************************************************/ datum memTestDataBus(volatile datum * address) {     datum pattern;       /*      * Perform a walking 1's test at the given address.      */     for (pattern = 1; pattern != 0; pattern <<= 1)     {         /*          * Write the test pattern. \nProgramming Embedded Systems in C and C++ \n- 75 -          */ \n        *address = pattern;          /*          * Read it back (immediately is okay for this test).          */         if (*address != pattern)          {             return (pattern);         }     }      return (0);  }   /* memTestDataBus() */ \n6.2.2.2 Address bus test  \nAfter confirming that the data bus works pr operly, you should next test the address bus. \nRemember that address bus problems lead to  overlapping memory locations. There are many \npossible addresses that could ove rlap. However, it is not nece ssary to check every possible \ncombination. You should instead follow the example of the previous data bus test and try to \nisolate each address bit during testing. You simp ly need to confirm that each of the address \npins can be set to and 1 without  affecting any of the others.  \nThe smallest set of addresses that will c over all possible combinations is the set of \n\"power-of-two\" addresses. These addresses are analogous to the set of data values used in the \nwalking 1's test. The corresponding memory locations are 00001h, 00002h, 00004h, 00008h, \n00010h, 00020h, and so forth. In addition, address 00000h must also be tested. The possibility of overlapping locations makes the address bus te st harder to implement. After writing to one \nof the addresses, you must check that none  of the others has been overwritten.  \nIt is important to note that not all of the address lines can be te sted in this way. Part of the \naddress-the leftmost bits-selects the memory chip  itself. Another part-the rightmost bits-might \nnot be significant if the data bus width is gr eater than 8 bits. These extra bits will remain \nconstant throughout the test and reduce the numbe r of test addresses. For example, if the \nprocessor has 20 address bits, as the 80188EB does , then it can address up to 1 megabyte of \nmemory. If you want to test a 128-kilobyte block of memory, the three most significant \naddress bits will remain constant.\n[1] In that case, only the 17 right most bits of the address bus \ncan actually be tested.  \n[1] 128 kilobytes is one-eighth of the total 1-megabyte address sp ace. \nProgramming Embedded Systems in C and C++ \n- 76 - To confirm that no two memory locations ov erlap, you should first write some initial data \nvalue at each power-of-two offset within the de vice. Then write a new value-an inverted copy \nof the initial value is a good choi ce-to the first test offset, and ve rify that the initial data value \nis still stored at every other power-of-two offset . If you find a location (oth er than the one just \nwritten) that contains the new data value, you have found a problem with the current address \nbit. If no overlapping is found, repeat the pr ocedure for each of the remaining offsets.  \nThe function memTestAddressBus  shows how this can be done  in practice. The function \naccepts two parameters. The first parameter is th e base address of the memory block to be \ntested, and the second is its size, in bytes. The size is used to determine which address bits \nshould be tested. For best results , the base address should contain a in each of those bits. If the \naddress bus test fails, the addr ess at which the first error wa s detected will be returned. \nOtherwise, the function returns NULL  to indicate success.  \n/**********************************************************************  \n * Function:    memTestAddressBus() \n *  * Description: Test the address bus wiring in a memory region by  *              performing a walking 1's test on the relevant bits  *              of the address and checking for aliasing.  The test  *              will find single-bit address failures such as stuck  *              -high, stuck-low, and shorted pins.  The base address  *              and size of the region are selected by the caller.  *  * Notes:       For best results, the selected base address should  *              have enough LSB 0's to guarantee single address bit  *              changes.  For example, to test a 64 KB region, select   *              a base address on a 64 KB boundary.  Also, select the   *              region size as a power-of-two--if at all possible.  *  * Returns:     NULL if the test succeeds.    *              A nonzero result is the first address at which an  *              aliasing problem was uncovered.  By examining the  *              contents of memory, it may be possible to gather  *              additional information about the problem.  *  **********************************************************************/ datum * memTestAddressBus(volatile datum * baseAddress, unsigned long nBytes) {     unsigned long addressMask = (nBytes - 1);     unsigned long offset;     unsigned long testOffset;      \nProgramming Embedded Systems in C and C++ \n- 77 -     datum pattern     = (datum) 0xAAAAAAAA; \n    datum antipattern = (datun) 0x55555555;      /*       * Write the default pattern at each of the power-of-two offsets..      */     for (offset = sizeof(datum); (offset & addressMask) != 0; offset <<= 1)     {         baseAddress[offset] = pattern;     }      /*      * Check for address bits stuck high.      */     testOffset = 0;     baseAddress[testOffset] = antipattern;      for (offset = sizeof(datum); (offset & addressMask) != 0; offset <<= 1)     {         if (baseAddress[offset] != pattern)         {             return ((datum *) &baseAddress[offset]);         }     }      baseAddress[testOffset] = pattern;      /*      * Check for address bits stuck low or shorted.      */     for (testOffset = sizeof(datum); (testOffset & addressMask) != 0;           testOffset <<= 1)     {         baseAddress[testOffset] = antipattern;          for (offset = sizeof(datum); (offset & addressMask) != 0;               offset <<= 1)         {             if ((baseAddress[offset] != pattern) && (offset != testOffset))             {                 return ((datum *) &baseAddress[testOffset]);             }         }  \nProgramming Embedded Systems in C and C++ \n- 78 -         baseAddress[testOffset] = pattern; \n    }      return (NULL);  }   /* memTestAddressBus() */  \n6.2.2.3 Device test  \nOnce you know that the address and data bus wiring are correct, it is ne cessary to test the \nintegrity of the memory device itself. The thing to test is that every bit in  the device is capable \nof holding both and 1. This is a fairly strai ghtforward test to implement, but it takes \nsignificantly longer to  execute than the previous two.  \nFor a complete device test, you must visit (wri te and verify) every memory location twice. \nYou are free to choose any data value for the fi rst pass, so long as you in vert that value during \nthe second. And because there is a possibility of missing memory ch ips, it is best to select a \nset of data that changes with ( but is not equivalent to) the ad dress. A simple example is an \nincrement test.  \nThe data values for the increment test are shown in the first two columns of Table 6-3 . The \nthird column shows the inverted data values used during the second pa ss of this test. The \nsecond pass represents a decrement test. There are many other possible choices of data, but \nthe incrementing data pattern is adequate and easy to compute.  \nTable 6-3. Data Values for an Increment Test  \nMemory Offset Binary Value Inverted Value \n000h 00000001 11111110 \n001h 00000010 11111101 \n002h 00000011 11111100 \n003h 00000100 11111011 \n... ... ... \n0FEh 11111111 00000000 \n0FFh 00000000 11111111 \nThe function memTestDevice  implements just such a two-pass increment/decrement test. It \naccepts two parameters from the caller. The firs t parameter is the starting address, and the \nsecond is the number of bytes to be tested. Th ese parameters give the user a maximum of \nProgramming Embedded Systems in C and C++ \n- 79 - control over which areas of memory will be  overwritten. The function will return NULL  on \nsuccess. Otherwise, the first address that cont ains an incorrect data  value is returned.  \n/********************************************************************** \n *  * Function:    memTestDevice()  *  * Description: Test the integrity of a physical memory device by  *              performing an increment/decrement test over the  *              entire region.  In the process every storage bit   *              in the device is tested as a zero and a one.  The  *              base address and the size of the region are  *              selected by the caller.  *  * Notes:         *  * Returns:     NULL if the test succeeds.  Also, in that case, the  *              entire memory region will be filled with zeros.  *  *              A nonzero result is the first address at which an  *              incorrect value was read back.  By examining the  *              contents of memory, it may be possible to gather  *              additional information about the problem.  *  **********************************************************************/ datum *  memTestDevice(volatile datum * baseAddress, unsigned long nBytes)   \n{     unsigned long offset;     unsigned long nWords = nBytes / sizeof(datum);      datum pattern;     datum antipattern;      /*      * Fill memory with a known pattern.      */     for (pattern = 1, offset = 0; offset < nWords; pattern++, offset++)     {         baseAddress[offset] = pattern;     }      /*      * Check each location and invert it for the second pass.      */ \nProgramming Embedded Systems in C and C++ \n- 80 -     for (pattern = 1, offset = 0; offset < nWords; pattern++, offset++) \n    {         if (baseAddress[offset] != pattern)         {             return ((datum *) &baseAddress[offset]);         }          antipattern = ~pattern;         baseAddress[offset] = antipattern;     }      /*      * Check each location for the inverted pattern and zero it.      */     for (pattern = 1, offset = 0; offset < nWords; pattern++, offset++)     {         antipattern = ~pattern;         if (baseAddress[offset] != antipattern)         {             return ((datum *) &baseAddress[offset]);         }          baseAddress[offset] = 0;     }      return (NULL);  }   /* memTestDevice() */ \n6.2.2.4 Putting it all together  \nTo make our discussion more concrete, let's c onsider a practical example. Suppose that we \nwanted to test the second 64-kilobyte chunk of the SRAM on the Arcom board. To do this, we would call each of the three test routines in turn. In each case, the first parameter would be the \nbase address of the memory block. Looking at  our memory map, we see that the physical \naddress is 10000h, which is repres ented by the segment:offset pair 0x1000:0000 . The width \nof the data bus is 8 bits (a feature of th e 80188EB processor), and th ere are a total of 64 \nkilobytes to be tested (co rresponding to the rightmost 16 bits of the address bus).  \nIf any of the memory test r outines returns a nonzero (or non- NULL ) value, we'll immediately \nturn on the red LED to visually indicate the error. Otherwise, afte r all three tests have \ncompleted successfully, we will turn on the gree n LED. In the event of an error, the test \nroutine that failed will return some info rmation about the problem encountered. This \ninformation can be useful when communicating w ith a hardware engineer  about the nature of \nProgramming Embedded Systems in C and C++ \n- 81 - the problem. However, it is visible only if we are running the test program in a debugger or \nemulator.  \nThe best way to proceed is to assume the best , download the test program, and let it run to \ncompletion. Then, if and only if the red LED  comes on, must you use the debugger to step \nthrough the program and examine the return code s and contents of the memory to see which \ntest failed and why.  \n#include \"led.h\" \n #define BASE_ADDRESS   (volatile datum *) 0x10000000 #define NUM_BYTES      0x10000  /**********************************************************************  *  * Function:    main()  *  * Description: Test the second 64 KB bank of SRAM.  *   * Notes:         *  * Returns:     0 on success.  *              Otherwise -1 indicates failure.  *  **********************************************************************/ main(void) {     if ((memTestDataBus(BASE_ADDRESS) != 0) ||         (memTestAddressBus(BASE_ADDRESS, NUM_BYTES) != NULL) ||         (memTestDevice(BASE_ADDRESS, NUM_BYTES) != NULL))     {         toggleLed(LED_RED);         return (-1);     }     else     {         toggleLed(LED_GREEN);         return (0);     }     }   /* main() */\n \nUnfortunately, it is not always possible to write  memory tests in a high-level language. For \nexample, C and C++ both require the use of a stack. But a stack itself requires working \nmemory. This might be reasonable in a system that has more than one memory device. For \nProgramming Embedded Systems in C and C++ \n- 82 - example, you might create a stack in an area of RAM that is already known to be working, \nwhile testing another memory device. In a co mmon such situation, a small SRAM could be \ntested from assembly and the stack could be cr eated there afterward. Then a larger block of \nDRAM could be tested using a nicer test algorithm, like the one shown earlier. If you cannot \nassume enough working RAM for the stack and da ta needs of the test program, then you will \nneed to rewrite these memory test rou tines entirely in assembly language.  \nAnother option is to run the memory test prog ram from an emulator. In this case, you could \nchoose to place the stack in an area of the emulator's own internal memory. By moving the emulator's internal memory around in the targ et memory map, you could systematically test \neach memory device on the target.  \nThe need for memory testing is perhaps most apparent during product development, when the \nreliability of the hardware and its design are still unproved. However, memory is one of the \nmost critical resources in any embedded system , so it might also be desirable to include a \nmemory test in the final release of your softwa re. In that case, the memory test and other \nhardware confidence tests should be run each time the system is powered-on or reset. \nTogether, this initial test suite forms a set of hardware diagnostics. If  one or more of the \ndiagnostics fail, a repair technician can be cal led in to diagnose the problem and repair or \nreplace the faulty hardware.  \n6.3 Validating Memory Contents \nIt does not usually make sense to perform the t ype of memory testing described earlier when \ndealing with ROM and hybrid memory devices. ROM devices cannot be written at all, and \nhybrid devices usually contain data or programs that cannot be overwritten. However, it \nshould be clear that the same sorts of memory  problems can occur with these devices. A chip \nmight be missing or improperly in serted or physically or electr ically damaged, or there could \nbe an electrical wiring problem. Rather than  just assuming that these nonvolatile memory \ndevices are functioning properly, you  would be better off having some way to confirm that the \ndevice is working and that the da ta it contains is valid. That 's where checksums and cyclic \nredundancy codes come in.  \n6.3.1 Checksums  \nHow can we tell if the data or program stor ed in a nonvolatile memory  device is still valid? \nOne of the easiest ways is to compute a ch ecksum of the data when it is known to be \ngood-prior to programming the ROM, for example.  Then, each time you want to confirm the \nvalidity of the data, you need only recalculate the checksum a nd compare the result to the \npreviously computed value. If the two checksums match, the data is assumed to be valid. By carefully selecting the checksum algorithm, we can  increase the probabili ty that specific types \nof errors will be detected.  \nProgramming Embedded Systems in C and C++ \n- 83 - The simplest checksum algorithm is to add up a ll the data bytes (or, if you prefer a 16-bit \nchecksum, words), discarding ca rries along the way. A notewort hy weakness of this algorithm \nis that if all of the data (inc luding the stored checksum) is acci dentally overwritten with 0's, \nthen this data corruption will be undetectable. Th e sum of a large block of zeros is also zero. \nThe simplest way to overcome this weakness is to  add a final step to the checksum algorithm: \ninvert the result. That way, if the data and checksum are somehow overwritten with 0's, the \ntest will fail because the pr oper checksum would be FFh.  \nUnfortunately, a simple sum-of-data checksum lik e this one cannot detect many of the most \ncommon data errors. Clearly if one bit of data is corrupted (switched from 1 to 0, or vice \nversa), the error would be detected. But what if two bits from the very same \"column\" \nhappened to be corrupted alternat ely (the first switches from 1 to 0, the other from to 1)? The \nproper checksum does not change, and the error would not be dete cted. If bit errors can occur, \nyou will probably want to use a better checksum algorithm. We'll see one of these in the next \nsection.  \nAfter computing the expected checksum, we'll need a place to store it. One option is to \ncompute the checksum ahead of time and define it as  a constant in the routine that verifies the \ndata. This method is attractive to the program mer but has several shortcomings. Foremost \namong them is the possibility that the data-and, as a result,  the expected checksum-might \nchange during the lifetime of the product. This is particularly likely if th e data being tested is \nactually embedded software that will be peri odically updated as bugs are fixed or new \nfeatures added.  \nA better idea is to store the checksum at so me fixed location in memory. For example, you \nmight decide to use the very last location of  the memory device being verified. This makes \ninsertion of the checksum easy-just compute the checksum and insert it into the memory image prior to programming the memory devi ce. When you recalcul ate the checksum, you \nsimply skip over the location that contains the expected result, and compare the new result to \nthe value stored there. Another good place to store the checksum is in another nonvolatile \nmemory device. Both of these solutions work very well in practice.  \n6.3.2 Cyclic Redundancy Codes  \nA cyclic redundancy code (CRC) is a specific checksum algorithm that is designed to detect \nthe most common data errors. The theory behind the CRC is quite mathematical and beyond \nthe scope of this book. However, cyclic redundan cy codes are frequently useful in embedded \napplications that require the storage or transmi ssion of large blocks of data. What follows is a \nbrief explanation of the CRC t echnique and some source code that shows how it can be done \nin C. Thankfully, you don't need to understand w hy CRCs detect data errors-or even how they \nare implemented-to take advantage of  their ability to detect errors.  \nHere's a very brief explanation of the mathem atics. When computing a CRC, you consider the \nset of data to be a very long string of 1's and 0's (called the message ). This binary string is \nProgramming Embedded Systems in C and C++ \n- 84 - divided-in a rather peculiar way-by a smaller fixed binary string called the generator \npolynomial . The remainder  of this binary long division is  the CRC checksum. By carefully \nselecting the generator polynomial for certain desirable mathematical properties, you can use \nthe resulting checksum to detect most (but neve r all) errors within the message. The strongest \nof these generator polynomials are able to detect all single and doubl e bit errors, and all \nodd-length strings of consecutive error bits. In addition, greater than 99.99% of all burst \nerrors-defined as a sequence of bits that has one  error at each end-can be detected. Together, \nthese types of errors account for a large percentage of the possibl e errors within any stored or \ntransmitted binary message.  \nThose generator polynomials with the very best  error-detection capabilities are frequently \nadopted as international standards. Thr ee such standards are parameterized in Table 6-4 . \nAssociated with each standard are its width (i n bits), the generator polynomial, a binary \nrepresentation of the polynomial called the diviso r, an initial value for the remainder, and a \nvalue to XOR (exclusive or) with the final remainder.[2]  \n[2] The divisor is simply a binary representation of the coefficie nts of the generator polynomial-each of which is either or \n1. To make this even more confusing, the highest-order coeffici ent of the generator polynomial (always a 1) is left out of \nthe binary representation. For example, the polynomial in the f irst standard, CCITT, has four nonzero coefficients. But the \ncorresponding binary representation has only three 1's in it (b its 12, 5, and 0). \nTable 6-4. International Stan dard Generator Polynomials  \n  CCITT CRC16 CRC32 \nChecksum size \n(width)  16 bits 16 bits 32 bits \nGenerator \npolynomial  x16 + x12 + x5 \n+ 1  x16 + x15 + \nx2 + 1  x32 + x26 + x23 + x22 + x16 + x12 + x11 + x10 + x8 + \nx7 + x5 + x4 + x2 + x1 + 1  \nDivisor \n(polynomial)  0x1021 0x8005 0x04C11DB7 \nInitial remainder  0xFFFF 0x0000 0xFFFFFFFF \nFinal XOR value  0x0000 0x0000 0xFFFFFFFF \nThe code that follows can be used to com pute any CRC formula that has a similar set of \nparameters.[3]  \n[3] There is one other potential twist called \"reflection\" that my  code does not support. You probably won't need that anyway. \nTo make this as easy as possibl e, I have defined all of the C RC parameters as constants. To \nchange to the CRC16 standard, simply change the values of the three constants. For CRC32, \nchange the three constants and redefine width  as type unsigned  long .  \nProgramming Embedded Systems in C and C++ \n- 85 - /* \n * The CRC parameters.  Currently configured for CCITT.  * Simply modify these to switch to another CRC standard.  */ #define POLYNOMIAL          0x1021 #define INITIAL_REMAINDER   0xFFFF #define FINAL_XOR_VALUE     0x0000  /*  * The width of the CRC calculation and result.  * Modify the typedef for an 8 or 32-bit CRC standard.  */ typedef unsigned short width;  #define WIDTH   (8 * sizeof(width)) #define TOPBIT  (1 << (WIDTH - 1))\n \nThe function crcInit  should be called first. It implements  the peculiar binary division required \nby the CRC algorithm. It will precompute the rema inder for each of the 256 possible values of \na byte of the message data. These intermediate results are stored in a global lookup table that \ncan be used by the crcCompute  function. By doing it this way, the CRC of a large message can \nbe computed a byte at a time rather than bit by bit. This reduces the CRC calculation time \nsignificantly.  \n/* \n * An array containing the pre-computed intermediate result for each  * possible byte of input.  This is used to speed up the computation.  */ width  crcTable[256];  /**********************************************************************  *  * Function:    crcInit()  *  * Description: Initialize the CRC lookup table.  This table is used  *              by crcCompute() to make CRC computation faster.  *  * Notes:       The mod-2 binary long division is implemented here.  *  * Returns:     None defined.  *  **********************************************************************/ void crcInit(void) { \nProgramming Embedded Systems in C and C++ \n- 86 -     width  remainder; \n    width  dividend;     int    bit;       /*      * Perform binary long division, a bit at a time.      */     for (dividend = 0; dividend < 256; dividend++)     {         /*          * Initialize the remainder.          */         remainder = dividend << (WIDTH - 8);          /*          * Shift and XOR with the polynomial.          */         for (bit = 0; bit < 8; bit++)         {             /*              * Try to divide the current data bit.              */             if (remainder & TOPBIT)             {                 remainder = (remainder << 1) ^ POLYNOMIAL;             }             else             {                 remainder = remainder << 1;             }         }          /*          * Save the result in the table.          */         crcTable[dividend] = remainder;     }  }   /* crcInit() */\n \nFinally, we arrive at the actual workhorse routine, crcCompute . This is a rou tine that you can \ncall over and over from your application to compute and verify CRC checksums. An \nadditional benefit of splitti ng the computation between crcInit  and crcCompute  is that the crcInit  \nfunction need not be executed on the embedded system. Instead, this function can be run in \nProgramming Embedded Systems in C and C++ \n- 87 - advance-on any computer-to produce the contents of  the lookup table. The values in the table \ncan then be stored in ROM (re quiring only 256 bytes of storage)  and referenced over and over \nby crcCompute .  \n/********************************************************************** \n *  * Function:    crcCompute()  *  * Description: Compute the CRC checksum of a binary message block.  *  * Notes:       This function expects that crcInit() has been called  *              first to initialize the CRC lookup table.  *  * Returns:     The CRC of the data.  *  **********************************************************************/ width crcCompute(unsigned char * message, unsigned int nBytes) {     unsigned int   offset;     unsigned char  byte;     width          remainder = INITIAL_REMAINDER;       /*      * Divide the message by the polynomial, a byte at a time.      */     for (offset = 0; offset < nBytes; offset++)     {         byte = (remainder >> (WIDTH - 8)) ^ message[offset];         remainder = crcTable[byte] ^ (remainder << 8);     }      /*      * The final remainder is the CRC result.      */     return (remainder ^ FINAL_XOR_VALUE);   }   /* crcCompute() */  \n6.4 Working with Flash Memory \nProgramming Embedded Systems in C and C++ \n- 88 - From the programmer's viewpoint, Flash is ar guably the most complicated memory device \never invented. The hardware interface has impr oved somewhat since the original devices were \nintroduced in 1988, but there is still a long way to  go. Reading from Flash memory is fast and \neasy, as it should be. In fact, reading data from a Flash is not all that different from reading \nfrom any other memory device.[4] The processor simply provides the address, and the memory \ndevice returns the data stored at  that location. Most Flash devices  enter this type of \"read\" \nmode automatically whenever the system is reset; no special initi alization sequence is \nrequired to enable reading.  \n[4] There is one small difference worth noting here. The erase and  write cycles take longer than the read cycle. So if a read \nis attempted in the middle of one of those operations, the resu lt will be either delayed or incorrect, depending on the device . \nWriting data to a Flash is much harder. Thr ee factors make writes difficult. First, each \nmemory location must be erased before it can be  rewritten. If the old da ta is not erased, the \nresult of the write operation will be some logi cal combination of the old and new values, and \nthe stored value will usually be so mething other than what you intended.  \nThe second thing that makes writes to a Flash difficu lt is that only one sector, or block, of the \ndevice can be erased at a time; it is impossible to  erase a single byte. Th e size of an individual \nsector varies by device, but it is usually on the order of several thousand bytes. For example, \nthe Flash device on the Arcom board-an AMD 29F010-has eight sectors, each containing 16 \nkilobytes.  \nFinally, the process of erasing the old data and writing the new varies from one manufacturer \nto another and is usually rather complicate d. These device programming interfaces are so \nawkward that it is usually best to add a layer of software to make the Flash memory easier to \nuse. If implemented, this hardware-specific la yer of software is usually called the Flash \ndriver.  \n6.4.1 Flash Drivers  \nBecause it can be difficult to write data to th e Flash device, it often makes sense to create a \nFlash driver. The purpose of the Fl ash driver is to hide the details of a specific chip from the \nrest of the software. This driver should pres ent a simple application programming interface \n(API) consisting of the erase and write operations. Parts of the application software that need \nto modify data stored in Flash memory simply call the driver to handle the details. This allows \nthe application programmer to make high-leve l requests like \"erase the block at address \nD0000h\" or \"write a block of data, beginni ng at address D4000h.\" It also keeps the \ndevice-specific code separate, so it can be easily modified if another manufacturer's Flash \ndevice is later used.  \nA Flash driver for the AMD 29F010 device on the Arcom board is shown below. This driver \ncontains just two functions: flashErase  and flashWrite . These functions erase an entire sector \nand write an array of bytes, respec tively. You should be able to s ee from the code listings that \nProgramming Embedded Systems in C and C++ \n- 89 - the interaction with the Flash device is no pi cnic. This code will work only with an AMD \n29F010 device. However, the same API could be  used with any Flash memory device.  \n#include \"tgt188eb.h\" \n /*  * Features of the AMD 29F010 Flash memory device.  */ #define FLASH_SIZE              0x20000 #define FLASH_BLOCK_SIZE        0x04000  #define UNLOCK1_OFFSET          0x5555 #define UNLOCK2_OFFSET          0x2AAA #define COMMAND_OFFSET          0x5555  #define FLASH_CMD_UNLOCK1       0xAA #define FLASH_CMD_UNLOCK2       0x55 #define FLASH_CMD_READ_RESET    0xF0 #define FLASH_CMD_AUTOSELECT    0x90 #define FLASH_CMD_BYTE_PROGRAM  0xA0 #define FLASH_CMD_ERASE_SETUP   0x80 #define FLASH_CMD_CHIP_ERASE    0x10 #define FLASH_CMD_SECTOR_ERASE  0x30  #define DQ7    0x80 #define DQ5    0x20  /**********************************************************************  *  * Function:    flashWrite()  *  * Description: Write data to consecutive locations in the Flash.  *  * Notes:       This function is specific to the AMD 29F010 Flash  *              memory.  In that device, a byte that has been  *              previously written must be erased before it can be  *              rewritten successfully.  *  * Returns:     The number of bytes successfully written.    *  **********************************************************************/ int flashWrite(unsigned char *      baseAddress,            const unsigned char  data[],             unsigned int         nBytes) \nProgramming Embedded Systems in C and C++ \n- 90 - { \n    unsigned char * flashBase = FLASH_BASE;     unsigned int    offset;      for (offset = 0; offset < nBytes; offset++)     {         /*          * Issue the command sequence for byte program.          */         flashBase[UNLOCK1_OFFSET] = FLASH_CMD_UNLOCK1;         flashBase[UNLOCK2_OFFSET] = FLASH_CMD_UNLOCK2;         flashBase[COMMAND_OFFSET] = FLASH_CMD_BYTE_PROGRAM;          /*          * Perform the actual write operation.          */         baseAddress[offset] = data[offset];             /*          * Wait for the operation to complete or time-out.          */         while (((baseAddress[offset] & DQ7) != (data[offset] & DQ7)) &&                 !(baseAddress[offset] & DQ5));          if ((baseAddress[offset] & DQ7) != (data[offset] & DQ7))         {             break;         }     }      return (offset);                            }   /* flashWrite() */  /**********************************************************************  *  * Function:    flashErase()  *  * Description: Erase a block of the Flash memory device.  *  * Notes:       This function is specific to the AMD 29F010 Flash   *              memory.  In this device, individual sectors may be  *              hardware protected.  If this algorithm encounters  *              a protected sector, the erase operation will fail \nProgramming Embedded Systems in C and C++ \n- 91 -  *              without notice. \n *  * Returns:     O on success.    *              Otherwise -1 indicates failure.  *  **********************************************************************/ int flashErase(unsigned char * sectorAddress) {     unsigned char * flashBase = FLASH_BASE;      /*      * Issue the command sequence for sector erase.      */     flashBase[UNLOCK1_OFFSET] = FLASH_CMD_UNLOCK1;     flashBase[UNLOCK2_OFFSET] = FLASH_CMD_UNLOCK2;     flashBase[COMMAND_OFFSET] = FLASH_CMD_ERASE_SETUP;     flashBase[UNLOCK1_OFFSET] = FLASH_CMD_UNLOCK1;     flashBase[UNLOCK2_OFFSET] = FLASH_CMD_UNLOCK2;      *sectorAddress = FLASH_CMD_SECTOR_ERASE;      /*      * Wait for the operation to complete or time-out.      */     while (!(*sectorAddress & DQ7) && !(*sectorAddress & DQ5));      if (!(*sectorAddress & DQ7))     {         return (-1);     }      return (0);   }   /* flashErase() */ \n \nOf course, this is just one possible way to in terface to a Flash memory-and not a particularly \nadvanced one at that. In part icular, this implementation does not handle any of the chip's \npossible errors. What if the erase op eration never completes? The function flashErase  will \njust keep spinning its wheels, waiting for that  to occur. A more robust implementation would \nuse a software time-out as a backup. For exampl e, if the Flash device doesn't respond within \ntwice the maximum expected time (as stated in the databook), the routine could stop polling \nand indicate the error to the caller (or user) in some way.  \nProgramming Embedded Systems in C and C++ \n- 92 - Another thing that people so metimes do with Flash memory is to implement a small \nfilesystem. Because the Flash me mory provides nonvolatile storage that is also rewriteable, it \ncan be thought of as similar to any other second ary storage system, such as a hard drive. In \nthe filesystem case, the functions provided by the driver would be more file-oriented. \nStandard filesystem functions like open , close , read, and write  provide a good starting point \nfor the driver's programming interface. The underly ing filesystem structure can be as simple \nor complex as your system requires. However, a well-understood format like the File \nAllocation Table (FAT) structure used by DOS  is good enough for most embedded projects.  \nProgramming Embedded Systems in C and C++ \n- 93 -",
    "Chapter 7": "before it can be used in a \nmultitasking environment. However, in  this case there is no race condition.[2] Rather, we need \nto use a mutex to eliminate the polling in the waitfor  method. By associating a mutex with each \nsoftware timer, we can put any task that is waiting for a timer to sleep and, thereby, free up the processor for the execution of lower-priority ready tasks. When the awaited timer expires, \nthe sleeping task will be reaw akened by the operating system.  \n[2] Recall that the timer hardware is initialized only once-during  the first constructor invocation-and thereafter, the \ntimer-specific registers are only read and written by one funct ion: the interrupt service routine. \nToward this end, a pointer to a mutex object, called pMutex , will be added to the class \ndefinition:  \nclass Timer \n{     public:          Timer();         ~Timer();          int   start(unsigned int nMilliseconds, TimerType = OneShot);         int   waitfor();         void  cancel();          TimerState    state;         TimerType     type;         unsigned int  length;  \n \n        Mutex *       pMutex;  \n \n        unsigned int  count;         Timer *       pNext;      private:  \nProgramming Embedded Systems in C and C++ \n- 139 -         static void interrupt  Interrupt(); \n}; \nThis pointer is initialized each time a softwa re timer is created by the constructor. And, \nthereafter, whenever a timer object is started, its mutex is taken as follows:  \n/********************************************************************** \n *   * Method:      start()  *  * Description: Start a software timer, based on the tick from the  *              underlying hardware timer.  * \n * Notes:       This version is ready for multitasking.  \n * \n * Returns:     0 on success, -1 if the timer is already in use.  *  **********************************************************************/ int Timer::start(unsigned int nMilliseconds, TimerType timerType) {     if (state != Idle)     {         return (-1);     } \n \n    //     // Take the mutex.  It will be released when the timer expires.     //     pMutex->take();  \n \n    //     // Initialize the software timer.     //     state  = Active;     type   = timerType;     length = nMilliseconds / MS_PER_TICK;      //     // Add this timer to the active timer list.     //     timerList.insert(this);      return (0);  \nProgramming Embedded Systems in C and C++ \n- 140 - }   /* start() */  \nBy taking the mutex when the timer is started, we guarantee that no task (not even the one \nthat started this timer) will be able to take it  again until the same mutex is released. And that \nwon't happen until either the timer expires naturall y (via the interrupt service routine) or the \ntimer is canceled manually (via the cancel  method). So the polling loop inside waitfor  can be \nreplaced with pMutex->take() , as follows:  \n/********************************************************************** \n *   * Method:      waitfor()  *  * Description: Wait for the software timer to finish.  * \n * Notes:       This version is ready for multitasking.  \n * \n * Returns:     0 on success, -1 if the timer is not running.  *  **********************************************************************/ int Timer::waitfor() {     if (state != Active)     {         return (-1);     }      //     // Wait for the timer to expire.     // \n    pMutex->take();  \n \n    //     // Restart or idle the timer, depending on its type.     //     if (type == Periodic)     {         state = Active;         timerList.insert(this);     }     else     { \n        pMutex->release();  \n        state = Idle; \n    } \nProgramming Embedded Systems in C and C++ \n- 141 -  \n    return (0);  }   /* waitfor() */\n \nWhen the timer does eventually expire, the inte rrupt service routine will release the mutex and \nthe calling task will awake inside waitfor . In the process of waking, the mutex will already be \ntaken for the next run of the timer. The mutex n eed only be released if the timer is of type \nOneShot  and, because of that, not automatically restarted.  \n9.3 Printing \"Hello, World!\" \nThe other part of our example application is a ta sk that prints the text string \"Hello, World!\" \nto one of the serial ports at a regular interval. Again, the timer driver is used to create the \nperiodicity. However, this task also depends on a se rial port driver that we haven't seen before. \nThe guts of the serial driver will be described in  the final two sections of  this chapter, but the \ntask that uses it is shown here. The only th ing you need to know about serial ports to \nunderstand this task is that a SerialPort  is a C++ class and that the puts method is used to \nprint a string of charact ers from that port.  \n#include \"timer.h\" \n#include \"serial.h\"  /**********************************************************************  *  * Function:    helloWorld()  *   * Description: Send a text message to the serial port periodically.  *  * Notes:       This outer loop is hardware-independent.    *  * Returns:     This routine contains an infinite loop.  *  **********************************************************************/ void helloWorld(void) {     Timer       timer;     SerialPort  serial(PORTA, 19200L);       timer.start(10000, Periodic);      // Start a periodic 10 s timer.      while (1) \nProgramming Embedded Systems in C and C++ \n- 142 -     { \n        serial.puts(\"Hello, World!\");  // Output a simple text message.         timer.waitfor();               // Wait for the timer to expire.     }  }   /* helloWorld() */\n \nThough the periodicity has a different  length, the general structure of this ta sk is the same as \nthat of the flashRed  function. So, the only thing left for us to discuss is the makeup of the serial \nport driver. We'll start with a description of a ge neralized serial ports interface and then finish \nwith the specifics of the serial controller found on the Arcom board.  \n9.4 Working with Serial Ports \nAt the application level, a serial port is simply a bidirecti onal data channel. This channel is \nusually terminated on each end with a hard ware device called a serial communications \ncontroller (SCC). Each serial por t within the SCC-there are usua lly at least two serial ports \nper controller-is connected to  the embedded processor on one side and to a cable (or the \nconnector for one) on the other side. At the othe r end of that cable th ere is usually a host \ncomputer (or some other embedded system) th at has an internal serial communications \ncontroller of its own.  \nOf course, the actual purpose of  the serial port is applicatio n-dependent. But the general idea \nis this: to communicate streams of data between two intelligen t systems or between one such \ndevice (the target) and a human ope rator. Typically, the smallest uni t of data that can be sent \nor received over a serial port is an 8-bit charac ter. So streams of binary data need to be \nreorganized into bytes before transmission. Th is restriction is sim ilar to that of C's stdio  \nlibrary, so it makes sense to borrow some pr ogramming conventions from that interface.  \nIn order to support serial communications and emulate a stdio-style interface, I've defined the \nSerialPort  class as it is shown below. This class ab stracts the application' s use of the serial \nport as bidirectional data channe l and makes the interface as similar as possible to what we've \nall seen before. In addition to the construc tor and destructor, the class includes four \nmethods- putchar ,[3] puts, getchar , and gets -for sending characters a nd strings of characters and \nreceiving the same. These routines are defi ned exactly as they would be in any ANSI \nC-compliant version of the header file stdio.h .  \n[3] You might be wondering why this method accepts an integer argu ment rather than a character. After all, we're sending 8-bit \ncharacters over the serial port, right? Well, don't ask me. I'm  just trying to be consistent with the ANSI C library standard \nand wondering the very same thing myself. \nHere's the actual class definition: \n#include \"circbuf.h\" \nProgramming Embedded Systems in C and C++ \n- 143 -  \n#define PORTA  0 #define PORTB  1  class SerialPort {     public:          SerialPort(int            port,                    unsigned long  baudRate = 19200L,                    unsigned int   txQueueSize = 64,   // Transmit Buffer Size                    unsigned int   rxQueueSize = 64);  // Receive Buffer Size         ~SerialPort();          int        putchar(int c);         int        puts(const char *s);          int        getchar();         char *     gets(char *s);      private:           int        channel;          CircBuf *  pTxQueue;            // Transmit Buffer         CircBuf *  pRxQueue;            // Receive Buffer };\n \nNote the private data members channel , pTxQueue , and pRxQueue . These are initialized \nwithin the constructor and used to interface to the hardware-specific part of the serial driver \ndescribed in the next section. I'll have more to say about this interface shortly, but for now \njust be aware that the SerialPort  class does not contain any c ode that is specific to a \nparticular Serial Controller. All of that is hidden inside the SCC class that it references.  \nLet's take a look at the SerialPort  constructor. This routine is responsible for initializing the \nthree private data members and configuring the requested data channel within the SCC \nhardware:  \n#include \"scc.h\" \n static SCC  scc;  /**********************************************************************  *   * Method:      SerialPort() \nProgramming Embedded Systems in C and C++ \n- 144 -  * \n * Description: Default constructor for the serial port class.  *  * Notes:      *  * Returns:     None defined.  *  **********************************************************************/ SerialPort::SerialPort(int            port,                        unsigned long  baudRate,                        unsigned int   txQueueSize,                        unsigned int   rxQueueSize) {     //     // Initialize the logical device.     //     switch (port)     {       case PORTA:         channel = 0;         break;        case PORTB:         channel = 1;         break;        default:         channel = -1;         break;     }      //     // Create input and output FIFOs.     //     pTxQueue = new CircBuf(txQueueSize);     pRxQueue = new CircBuf(rxQueueSize);      //      // Initialize the hardware device.     //      scc.reset(channel);     scc.init(channel, baudRate, pTxQueue, pRxQueue);  }   /* SerialPort() */\n \nProgramming Embedded Systems in C and C++ \n- 145 - Once a SerialPort  object has been created, the afor ementioned methods for sending and \nreceiving data can be used. For example, in the helloWorld  function shown earlier, \nputs(\"Hello,  World!\")  is the statement that sends the te xt string to seri al port A (a.k.a. \nSCC channel 0). The data is sent over the serial  channel at a rate of 19,200 bits per second, as \nselected by the baudRate  parameter to the SerialPort  constructor.  \nThe send and receive methods rely on the circular buffers pointed to by pTxQueue  and \npRxQueue , respectively. pTxQueue  is a transmit buffer that provides overflow memory in case \nthe rate at which characters are sent by the app lication exceeds the baud rate of the channel. \nThis usually happens in short spurts, so it is e xpected that the transmit buffer won't usually fill \nup all the way. Similarly, the receive buffer, pRxQueue , provides overflow memory for bytes \nthat have been received at th e serial port but not yet read by the application. By default, the \nabove constructor creates each of these as 64-byt e buffers. However, these sizes can be set to \nsmaller or larger values, depending on the need s of your application, si mply by overriding the \ndefault arguments to the constructor.  \nThe implementations of the send methods putchar  and puts are shown below. In putchar  we start \nby checking if the transmit buffer is already full . If so, we return an error indication to the \ncaller, so he will know that the character was not  sent. Otherwise, we add the new character to \nthe transmit buffer, ensure that the SCC transm it engine is running, and return success. The \nputs method makes a series of calls to putchar , one for each character in the string and then \nadds a newline character at the end.  \n/********************************************************************** \n *   * Method:      putchar()  *  * Description: Write one character to the serial port.  *  * Notes:  *  * Returns:     The transmitted character is returned on success.    *              -1 is returned in the case of an error.  *  **********************************************************************/ int SerialPort::putchar(int c) {     if (pTxQueue->isFull())     {         return (-1);     }      //     // Add the character to the transmit FIFO. \nProgramming Embedded Systems in C and C++ \n- 146 -     // \n    pTxQueue->add((char) c);      //     // Start the transmit engine (if it's stalled).     //     scc.txStart(channel);      return (c);  }   /* putchar() */   /**********************************************************************  *   * Method:      puts()  *  * Description: Copies the null-terminated string s to the serial  *              port and appends a newline character.  *  * Notes:       In rare cases, this function may return success though  *              the newline was not actually sent.  *  * Returns:     The number of characters transmitted successfully.  *              Otherwise, -1 is returned to indicate error.  *  **********************************************************************/ int SerialPort::puts(const char * s) {     const char *  p;       //     // Send each character of the string.     //     for (p = s; *p != '\\0'; p++)     {         if (putchar(*p) < 0) break;     }      //     // Add a newline character.     // \nProgramming Embedded Systems in C and C++ \n- 147 -     putchar('\\n'); \n     return ((p - s) + 1);  }   /* puts() */\n \nThe receive method getchar  is similar to putchar . It starts by checking if the receive buffer is \nempty. If so, an error code is  returned. Otherwise, one byte of data is removed from the \nreceive buffer and returned to the caller. The gets method calls getchar  repeatedly until either a \nnewline character is found or there is no more data  available at the serial  port. It then returns \nwhatever string was found up to that point. The code for both of these methods follows:  \n/********************************************************************** \n *   * Method:      getchar()  *  * Description: Read one character from the serial port.  *  * Notes:  *  * Returns:     The next character found on this input stream.  *              -1 is returned in the case of an error.  *  **********************************************************************/ int SerialPort::getchar(void) {     int  c;       if (pRxQueue->isEmpty())     {         return (-1);               // There is no input data available.     }      int rxStalled = pRxQueue->isFull();      //     // Read the next byte out of the receive FIFO.     //     c = pRxQueue->remove();      //     // If the receive engine is stalled, restart it.     // \nProgramming Embedded Systems in C and C++ \n- 148 -     if (rxStalled) \n    {         scc.rxStart(channel);     }      return (c);  }   /* getchar() */   /**********************************************************************  *   * Method:      gets()  *  * Description: Collects a string of characters terminated by a new-  *              line character from the serial port and places it in s.    *              The newline character is replaced by a null character.  *  * Notes:       The caller is responsible for allocating adequate space  *              for the string.  *  * Warnings:    This function does not block waiting for a newline.    *              If a complete string is not found, it will return   *              whatever is available in the receive queue.  *  * Returns:     A pointer to the string.  *              Otherwise, NULL is returned to indicate an error.  *  **********************************************************************/ char * SerialPort::gets(char * s) {     char *  p;     int     c;       //     // Read characters until a newline is found or no more data.     //     for (p = s; (c = getchar()) != '\\n' && c >= 0; p++)     {         *p = c;     }  \nProgramming Embedded Systems in C and C++ \n- 149 -     // \n    // Terminate the string.     //     *p = '\\0';      return (s);  }   /* gets() */ \n9.5 The Zilog 85230 Serial Controller \nThe two serial ports on the Arcom board ar e part of the same Zilog 85230 Serial \nCommunications Controller. This particular chip is, unfortuna tely, rather complicated to \nconfigure and use. So, ra ther than fill up the SerialPort  class shown earlier with \ndevice-specific code, I decided to divide the serial driver into two parts. The upper layer is the \nclass we have just discussed. This upper laye r will work with any two-channel SCC that \nprovides byte-oriented transmit a nd receive interfaces and configur able baud rates. All that is \nnecessary is to implement a device-specific SCC class (the lower layer described next) that \nhas the same reset , init, txStart , and rxStart  interfaces as those called from the SerialPort  \nclass.  \nIn fact, one of the reasons the Zilog 85230 SCC de vice is so difficult to configure and use is \nthat it has many more options than are really nece ssary for this simple application. The chip is \ncapable of sending not only bytes but also char acters that have any number of bits up to 8. \nAnd in addition to being able to  select the baud rate, it is also possible to configure many \nother features of one or both channels and to support a variety of other communication \nprotocols.  \nHere's how the SCC class is actually defined: \n#include \"circbuf.h\" \n class SCC {     public:                  SCC();          void  reset(int channel);         void  init(int channel, unsigned long baudRate,                    CircBuf * pTxQueue, CircBuf * pRxQueue);          void  txStart(int channel);         void  rxStart(int channel); \nProgramming Embedded Systems in C and C++ \n- 150 -  \n    private:              static void interrupt  Interrupt(void); };\n \nNotice that this class also depends upon the CircBuf  class. The pTxQueue  and pRxQueue  \narguments to the init method are used to establish the inpu t and output buffers for that channel. \nThis makes it possible to link a logical SerialPort  object with one of the physical channels \nwithin the SCC device. The reason for defining the init method separately from the \nconstructor is that most SCC chips control two or  more serial channels. The constructor resets \nthem both the first time it is called. Then, init is called to set the baud rate and other \nparameters for a particular channel.  \nEverything else about the SCC class is an internal feature th at is specific to the Zilog 85230 \ndevice. For that reason, I have decided not to li st or explain this ra ther long and complex \nmodule within the book. Suffice it to  say that the code consists  of macros for reading and \nwriting the registers of the device, an interrupt  service routine to ha ndle receive and transmit \ninterrupts, and methods for restarting the re ceive and transmit processes if they have \npreviously stalled while waiting for more data. Inte rested readers will find the actual code in \nthe file scc.cpp .  \nProgramming Embedded Systems in C and C++ \n- 151 -",
    "Chapter 8": ". Operating Systems \nosophobia  n. A common fear among embedded systems programmers.   \nAll but the most trivial of embedded programs w ill benefit from the inclusion of an operating \nsystem. This can range from a small kernel written by you to a full-featured commercial \noperating system. Either way, you'll need to know what features are the most important and \nhow their implementation will affect  the rest of your software. At the very least, you need to \nunderstand what an embedded operating system l ooks like on the outside. But there's probably \nno better way to understand the exte rior interfaces than to ex amine a small operating system \nin its entirety. So that's what we'll do in this chapter.  \n8.1 History and Purpose \nIn the early days of computi ng there was no such thing as an  operating system. Application \nprogrammers were completely responsible for controlling and monitori ng the state of the \nprocessor and other hardware. In fact, the purpose of the fi rst operating systems was to \nprovide a virtual hardware platform that made  application programs easier to write. To \naccomplish this goal, operating system develope rs needed only provide a loose collection of \nroutines-much like a modern soft ware library-for re setting the hardware to a known state, \nreading the state of the inputs, and changing the state of  the outputs.  \nModern operating systems add to this the ab ility to execute multiple software tasks \nsimultaneously on a single processor. Each such task is a piece of the software that can be \nseparated from and run independently of the re st. A set of embedded software requirements \ncan usually be decomposed into a small number of such independent pieces. For example, the \nprinter-sharing device described in",
    "Chapter 9": ". Putting It All Together \nA sufficiently high level of  technology is indistinguishable from magic.  \n-Arthur C. Clarke In this chapter, I'll attempt to bring all of the elements we've discussed so far together into a \ncomplete embedded application. I don't have much new material to add to the discussion at \nthis point, so the body of the",
    "Chapter 10": ". Optimizing Your Code \nThings should be made as simple  as possible, but not any simpler.  \n-Albert Einstein \nThough getting the software to work correctly s eems like the logical last step for a project, \nthis is not always the case in embedded systems development. The need for low-cost versions of our products drives hardware designers to provide just barely enough memory and \nprocessing power to get the job done. Of course , during the software development phase of \nthe project it is more important to get the pr ogram to work correctly. And toward that end \nthere are usually one or more \"development \" boards around, each with additional memory, a \nfaster processor, or both. Thes e boards are used to get the so ftware working correctly, and \nthen the final phase of the project becomes code optimization. The goal of this final step is to \nmake the working program run on the lower-cos t \"production\" version of the hardware.  \n10.1 Increasing Code Efficiency \nSome degree of code optimization is provided by all modern C and C++ compilers. However, \nmost of the optimization techniques that are performed by a compiler involve a tradeoff \nbetween execution speed and code size. Your prog ram can be made either faster or smaller, \nbut not both. In fact, an improvement in one of  these areas can have a negative impact on the \nother. It is up to the programmer to decide which of these improvements is most important to \nher. Given that single piece of information, the compiler's optimization phase can make the \nappropriate choice whenever a speed ve rsus size tradeoff is encountered.  \nBecause you can't have the compiler perform both types of optimization for you, I \nrecommend letting it do what it can to redu ce the size of your program. Execution speed is \nusually important only within certain time-critical or frequently executed sections of the code, \nand there are many things you can do to improve  the efficiency of those sections by hand. \nHowever, code size is a difficult thing to influence manually, and the compiler is in a much \nbetter position to make this change across all of your software modules.  \nBy the time your program is working you might already know, or have a pretty good idea, \nwhich subroutines and modules are the most cr itical for overall code efficiency. Interrupt \nservice routines, high-priority tasks, calculatio ns with real-time deadlines, and functions that \nare either compute-intensive or frequently call ed are all likely candida tes. A tool called a \nprofiler , included with some software development suites, can be used to narrow your focus \nto those routines in which the program sp ends most (or too much) of its time.  \nOnce you've identified the routines  that require greater code efficiency, one or more of the \nfollowing techniques can be used to reduce their execution time:  \nProgramming Embedded Systems in C and C++ \n- 152 - Inline functions   \nIn C++, the keyword inline  can be added to any functi on declaration. This keyword \nmakes a request to the compiler to replace all calls to the indi cated function with \ncopies of the code that is in side. This eliminates the runtime overhead associated with \nthe actual function call and is most effective when the inline function is called \nfrequently but contains only a few lines of code.  \nInline functions provide a pe rfect example of how execution speed and code size are \nsometimes inversely linked. The repetitive addi tion of the inline code will increase the \nsize of your program in direct proportion to the number of times the function is called. \nAnd, obviously, the larger the function, the mo re significant the size increase will be. \nThe resulting program runs faster, but now requires more ROM.  \nTable lookups   \nA switch  statement is one common programming techni que to be used with care. Each test \nand jump that makes up the machine language implementation uses up valuable processor \ntime simply deciding what work should be done  next. To speed things up, try to put the \nindividual cases in order by their relative fre quency of occurrence. In other words, put the \nmost likely cases first and the least likely case s last. This will reduce the average execution \ntime, though it will not improve at all upon the worst-case time.  \nIf there is a lot of work to be done within each case, it might be more efficient to replace the \nentire switch  statement with a table of pointers to  functions. For example, the following \nblock of code is a candidate for this improvement:  \nenum NodeType { NodeA, NodeB, NodeC }; \n switch (getNodeType()) {     case NodeA:         .         .     case NodeB:         .         .     case NodeC:         .         . }\n \nTo speed things up, we would replace this switch  statement with the following \nalternative. The first part of this is the setup: the creation of an array of function \nProgramming Embedded Systems in C and C++ \n- 153 - pointers. The second part is a one-line replacement for the switch  statement that \nexecutes more efficiently.  \nint processNodeA(void); \nint processNodeB(void); int processNodeC(void);  /*  * Establishment of a table of pointers to functions.  */ int (* nodeFunctions[])() = { processNodeA, processNodeB, processNodeC };   . .  /*  * The entire switch statement is replaced by the next line.  */ status = nodeFunctions[getNodeType()]();\n \nHand-coded assembly   \nSome software modules are best written  in assembly language. This gives the \nprogrammer an opportunity to make them as efficient as possible. Though most \nC/C++ compilers produce much better machine code than the average programmer, a good programmer can still do better than th e average compiler for a given function. \nFor example, early in my career I implemen ted a digital filtering algorithm in C and \ntargeted it to a TI TMS320C30 DSP. The compiler we had back then was either \nunaware or unable to take adva ntage of a special instructi on that performed exactly the \nmathematical operations I needed. By ma nually replacing one l oop of the C program \nwith inline assembly instructions that di d the same thing, I was able to decrease the \noverall computation time by more than a factor of ten.  \nRegister variables   \nThe keyword register  can be used when declaring lo cal variables. This asks the \ncompiler to place the variable into a general- purpose register, rather than on the stack. \nUsed judiciously, this technique provides  hints to the compiler about the most \nfrequently accessed variables and will so mewhat enhance the performance of the \nfunction. The more frequently the function is  called, the more likel y such a change is \nto improve the code's performance.  \nGlobal variables   \nProgramming Embedded Systems in C and C++ \n- 154 - It is more efficient to use a global variable than to pass a parameter to a function. This \neliminates the need to push the parameter onto the stack before the function call and pop it back off once the function is comp leted. In fact, the most efficient \nimplementation of any subroutine would have  no parameters at all. However, the \ndecision to use a global variable can also have some negative effects on the program. \nThe software engineering community generally  discourages the use of global variables, \nin an effort to promote the goals of modularity and reentrancy, which are also \nimportant considerations.  \nPolling   \nInterrupt service routines are often used to improve program efficiency. However, \nthere are some rare cases in which the overh ead associated with the interrupts actually \ncauses an inefficiency. These are cases in wh ich the average time between interrupts is \nof the same order of magnitude as the inte rrupt latency. In such cases it might be \nbetter to use polling to communicate with th e hardware device. Of course, this too \nleads to a less modular software design.  \nFixed-point arithmetic   \nUnless your target platform includes a floa ting-point coprocessor, you'll pay a very \nlarge penalty for manipulating float  data in your program. The compiler-supplied \nfloating-point library contai ns a set of software subr outines that emulate the \ninstruction set of a floating- point coprocessor. Many of these functions take a long \ntime to execute relative to their integer count erparts and also might not be reentrant.  \nIf you are only using floating-point for a few calculations, it might be better to \nreimplement the calculations themselves us ing fixed-point arithmetic only. Although it \nmight be difficult to see ju st how this can be done, it is  theoretically possible to \nperform any floating-point calcu lation with fixed-point arithmetic. (After all, that's \nhow the floating-point software library does it,  right?) Your biggest  advantage is that \nyou probably don't need to implement the en tire IEEE 754 standard just to perform \none or two calculations. If you do need that kind of complete func tionality, stick with \nthe compiler's floating-point li brary and look for other ways  to speed up your program.  \n10.2 Decreasing Code Size \nAs I said earlier, when it comes to reducing c ode size your best bet is to let the compiler do \nthe work for you. However, if the resulting progra m is still too large for your available ROM, \nthere are several programming techniques you can use to further reduce the size of your \nprogram. In this section we'll discuss both auto matic and manual code size optimizations.  \nOf course, Murphy's Law dictates that the firs t time you enable the compiler's optimization \nfeature your previously working program will sudde nly fail. Perhaps the most notorious of the \nProgramming Embedded Systems in C and C++ \n- 155 - automatic optimizations is \" dead code eliminat ion.\" This optimization eliminates code that \nthe compiler believes to be either redundant or  irrelevant. For exampl e, adding zero to a \nvariable requires no runtime calculation whatsoev er. But you might still want the compiler to \ngenerate those \"irrelevant\" instructions if they perform some function that the compiler \ndoesn't know about.  \nFor example, given the following block of code, most optimizing compilers would remove the \nfirst statement because the value of *pControl  is not used before it is overwritten (on the \nthird line):  \n    *pControl = DISABLE;  \n    *pData    = 'a'; \n    *pControl = ENABLE;  \nBut what if pControl  and pData  are actually pointers to memory -mapped device registers? In \nthat case, the peripheral device would not receive the DISABLE  command before the byte of \ndata was written. This could potentially wreak havoc on all future inte ractions between the \nprocessor and this peri pheral. To protect yourself from su ch problems, you must declare all \npointers to memory-mapped regist ers and global variables that ar e shared between threads (or \na thread and an ISR) with the keyword volatile . And if you miss just one of them, Murphy's \nLaw will come back to haunt you in the fina l days of your project. I guarantee it.  \n Never make the mistake of assumi ng that the optimized program will \nbehave the same as the unoptimized one. You must completely retest \nyour software at each new optimizati on level to be sure its behavior \nhasn't changed.   \nTo make matters worse, debugging an optimized program is challenging, to say the least. \nWith the compiler's optimization enabled, the co rrelation between a line of source code and \nthe set of processor instructions that implemen ts that line is much weaker. Those particular \ninstructions might have moved or been split up, or two similar code blocks might now share a \ncommon implementation. In fact, some lines of  the high-level language program might have \nbeen removed from the program altogether (as they  were in the previous example)! As a result, \nyou might be unable to set a breakpoint on a par ticular line of the program or examine the \nvalue of a variable of interest.  \nOnce you've got the automatic optimizations work ing, here are some tips for further reducing \nthe size of your code by hand:  \nAvoid standard library routines   \nOne of the best things you can do to reduce the size of your program is to avoid using \nlarge standard library routin es. Many of the largest are expensive only because they \ntry to handle all possible cases. It might be  possible to implement a subset of the \nfunctionality yourself with significantly less code. For example, the standard C \nProgramming Embedded Systems in C and C++ \n- 156 - library's sprintf  routine is notoriously large. Much of this bulk is located within the \nfloating-point manipulation routines on wh ich it depends. But if you don't need to \nformat and display floating-point values ( %f or %d ), you could write your own \ninteger-only version of sprintf  and save several kilobytes of  code space. In fact, a few \nimplementations of the standard C library (Cygnus' newlib  comes to mind) include just \nsuch a function, called siprintf .  \nNative word size   \nEvery processor has a native word size, a nd the ANSI C and C++ st andards state that \ndata type int must always map to that size. Mani pulation of smaller and larger data \ntypes sometimes requires the use of additional machine-language instructions. By consistently using int whenever possible in your program , you might be able to shave \na precious few hundred bytes from your program.  \nGoto statements   \nAs with global variables, good software engineer ing practice dictates ag ainst the use of this \ntechnique. But in a pinch, goto  statements can be used to remove complicated control \nstructures or to share a block of oft repeated code.  \nIn addition to these techniques, several of the ones described in  the previous section could be \nhelpful, specifically table lookups, hand-code d assembly, register variables, and global \nvariables. Of these, the use of hand-coded assembly will usually yield the largest decrease in \ncode size.  \n10.3 Reducing Memory Usage \nIn some cases, it is RAM rather than ROM that  is the limiting factor for your application. In \nthese cases, you'll want to reduce your depe ndence on global data, the stack, and the heap. \nThese are all optimizations better made by the programmer than by the compiler.  \nBecause ROM is usually cheaper than RAM (on a per-byte basis), one acceptable strategy for \nreducing the amount of global data  might be to move constant data into ROM. This can be \ndone automatically by the compiler if you declare all of your constant data with the keyword \nconst . Most C/C++ compilers place all of the constant global da ta they encounter into a \nspecial data segment that is recognizable to th e locator as ROM-able. This technique is most \nvaluable if there are lots of strings or table-or iented data that does not  change at runtime.  \nIf some of the data is fixed once the program  is running but not necessarily constant, the \nconstant data segment could be placed in a hybrid memory device instead. This memory \ndevice could then be updated over a network or by a technician assigned to make the change. \nAn example of such data is the sales tax rate  for each locale in which your product will be \nProgramming Embedded Systems in C and C++ \n- 157 - deployed. If a tax rate changes, the memory device can be updated, but additional RAM can \nbe saved in the meantime.  \nStack size reductions can also lower your program's RAM require ment. One way to figure out \nexactly how much stack you need is  to fill the entire memory ar ea reserved for the stack with \na special data pattern. Then, af ter the software has been runni ng for a while-preferably under \nboth normal and stressful conditions-use a debugge r to examine the modified stack. The part \nof the stack memory area that  still contains your special data pattern has never been \noverwritten, so it is safe to reduce th e size of the stack area by that amount.[1]  \n[1] Of course, you might want to leave a little extra space on the  stack-just in case your testing didn't last long enough or \ndid not accurately reflect all possible runtime scenarios. Neve r forget that a stack overflow is a potentially fatal event \nfor your software and to be avoided at all costs. \nBe especially conscious of stack space if you are using a real-time operating system. Most \noperating systems create a separate stack for each task. These stacks are used for function \ncalls and interrupt servic e routines that occur within the context of a task. You can determine \nthe amount of stack required for each task st ack in the manner described earlier. You might \nalso try to reduce the number of  tasks or switch to an operati ng system that has a separate \n\"interrupt stack\" for executi on of all interrupt service ro utines. The latter method can \nsignificantly reduce the stack size requirement of each task.  \nThe size of the heap is limited to the amount of  RAM left over after all of the global data and \nstack space has been allocated. If the heap is  too small, your program will not be able to \nallocate memory when it is needed, so al ways be sure to compare the result of malloc  or new \nwith NULL  before dereferencing it. If you've tried a ll of these suggestions and your program is \nstill requiring too much memory, you might have no choice but to eliminate the heap \naltogether.  \n10.4 Limiting the Impact of C++ \nOne of the biggest issues I faced upon decidi ng to write this book was whether or not to \ninclude C++ in the discussion. Despite my famili arity with C++, I had written almost all of \nmy embedded software in C and assembly. In a ddition, there has been mu ch debate within the \nembedded software community about whether C ++ is worth the performance penalty. It is \ngenerally agreed that C++ progr ams produce larger executables that run more slowly than \nprograms written entirely in C. However, C ++ has many benefits for the programmer, and I \nwanted to talk about some of those benefits in the book. So I ultimately decided to include \nC++ in the discussion, but to use in my ex amples only those features with the least \nperformance penalty.  \nI believe that many readers will face the same issue in their own embedded systems \nprogramming. Before ending the book, I wanted to briefly justify each of  the C++ features I \nhave used and to warn you about some of the more expensive features that I did not use.  \nProgramming Embedded Systems in C and C++ \n- 158 - The Embedded C++ Standard \nYou might be wondering why the creators  of the C++ language  included so many \nexpensive-in terms of execution time and code size-features. You are not alone; \npeople around the world have wondered the sa me thing-especially the users of C++ \nfor embedded programming. Many of these e xpensive features are recent additions \nthat are neither strictly n ecessary nor part of the orig inal C++ specification. These \nfeatures have been added one by one as  part of the ongoing \"standardization\" \nprocess.  \nIn 1996, a group of Japanese proc essor vendors joined together  to define a subset of \nthe C++ language and libraries that is  better suited for embedded software \ndevelopment. They call their new industry standard Embedded C++. Surprisingly, for its young age, it has already generated a great deal of intere st and excitement \nwithin the C++ user community.  \nA proper subset of the draft C++ sta ndard, Embedded C++ omits pretty much \nanything that can be left out without limiting the expressiveness of the underlying \nlanguage. This includes not only expensive feat ures like multiple inheritance, virtual \nbase classes, runtime type identification, and exception handling, but also some of \nthe newest additions like templates, namesp aces, and new-style casts. What's left is a \nsimpler version of C++ that is still object -oriented and a superset of C, but with \nsignificantly less runtime overhead and smaller runtime libraries.  \nA number of commercial C++ compile rs already support the Embedded C++ \nstandard specifically. Several others allow you to manually disable individual \nlanguage features, thus enabling you to em ulate Embedded C++ or create your very \nown flavor of the C++ language.  \nOf course, not everything introduced in C ++ is expensive. Many older C++ compilers \nincorporate a technology called C-front that tu rns C++ programs into C and feeds the result \ninto a standard C compiler. The mere fact th at this is possible s hould suggest that the \nsyntactical differences between the languages have  little or no runtime cost associated with \nthem.[2] It is only the newest C++ features, like templates, that  cannot be handled in this \nmanner.  \n[2] Moreover, it should be clear that there is no penalty for comp iling an ordinary C program with a C++ compiler. \nFor example, the definition of a class  is completely benign. The list of public and private \nmember data and functions ar e not much different than a struct  and a list of function \nprototypes. However, the C++ compiler is able to use the public  and private  keywords to \ndetermine which method calls and data accesse s are allowed and disallowed. Because this \ndetermination is made at compile time, there is no penalty paid at runtime. The addition of \nclasses alone does not affect either the code size or effi ciency of your programs.  \nProgramming Embedded Systems in C and C++ \n- 159 - Default parameter values are also penalty-free. The compiler simply inserts code to pass the \ndefault value whenever the function is called w ithout an argument in that position. Similarly, \nfunction name overloading is a compile-time m odification. Functions with the same names \nbut different parameters are each assigned uni que names during the compilation process. The \ncompiler alters the function name each time it appears in your program, and the linker matches them up appropriately. I haven't used this  feature of C++ in a ny of my examples, but \nI could have done so without affecting performance.  \nOperator overloading is anothe r feature I could have used but  didn't. Whenever the compiler \nsees such an operator, it simply replaces it w ith the appropriate function call. So in the code \nlisting that follows, the last two lines are equi valent and the performance penalty is easily \nunderstood:  \nComplex  a, b, c; \n c = operator+(a, b);                 // The traditional way: Function Call c = a + b;                           // The C++ way: Operator Overloading\n \nConstructors and destruct ors also have a slight penalty a ssociated with them. These special \nmethods are guaranteed to be called each time an object of the type is created or goes out of \nscope, respectively. However, this small amount of overhead is a reasona ble price to pay for \nfewer bugs. Constructors eliminate an entire cl ass of C programming errors having to do with \nuninitialized data structures. This feature has also proved us eful for hiding the awkward \ninitialization sequences that are a ssociated with complex classes like Timer  and Task .  \nVirtual functions also have a re asonable cost/benefit ra tio. Without going into too much detail \nabout what virtual functions are,  let's just say that polymorphi sm would be impossible without \nthem. And without polymorphism, C++ would not  be a true object-oriented language. The \nonly significant cost of virtual functions is  one additional memory lookup before a virtual \nfunction can be called. Ordinary functi on and method calls are not affected.  \nThe features of C++ that are too expensive for my taste are templates, exceptions, and runtime \ntype identification. All three of  these negatively impact code si ze, and exceptions and runtime \ntype identification also increase execution time. Before deciding whether to use these features, \nyou might want to do some experiments to see how they will affect the size and speed of your \nown application.  \nProgramming Embedded Systems in C and C++ \n- 160 - Appendix A. Arcom's Target188EB \nAll of the examples in this book have been wr itten for and tested on an embedded platform \ncalled the Target188EB. This board is a low- cost, high-speed embedde d controller designed, \nmanufactured, and sold by Arcom Control Systems. The following paragraphs contain \ninformation about the hardware, required a nd included software development tools, and \ninstructions for orderi ng a board for yourself.  \nThe Target188EB hardware consists of the following: Processor: Intel 80188EB (25 MHz) \nRAM: 128K of SRAM (256K availabl e), with optional battery backup \nROM: 128K of EPROM and 128K of Flash (512K maximum) \nTwo RS232-compatible serial ports (with external DB9 connectors) \n24-channel parallel port \n3 programmable timer/counters 4 available interrupt inputs \nAn 8-bit PC/104 expansion bus interface \nAn optional 8-bit STEBus expansion interface A remote debugging adapter containing two a dditional RS232-compatible serial ports  \nSoftware development for this board is as easy as PC programming. Free development tools \nand utilities included with the board allow you to develop your embedded application in \nC/C++ or assembly language, using Borland' s C++ compiler and Turbo Assembler. In \naddition, a debug monitor preinstalled in the onb oard Flash memory makes it possible to use \nBorland's Turbo Debugger to easily find and fix bugs  in your application. Finally, a library of \nhardware interface routines makes manipula ting the onboard hardware as simple as \ninteracting with C's stdio  library.  \nAll of the programs in this book were asse mbled, compiled, linked, and debugged with a copy \nof Borland C++ 3.1. However, any version of th e Borland tool chain capable of producing \ncode for an 80186 processor will do just fine . This includes the popular versions 3.1, 4.5, and \n4.52. If you already have one of these versions, you can use that. Otherwise, you might want \nto check with Arcom to find out if  the latest version of Borland's tools is compatible with their \ndevelopment and debugging tools.  \nProgramming Embedded Systems in C and C++ \n- 161 - In small quantities, the Target188EB board (part number TARGET188E B-SBC) retails for \n$195.[A] Ordinarily, this does not include the so ftware development tools and power supply. \nHowever, Arcom has generously agreed to pr ovide a free copy of their Target Development \nKit (a $100 value) to readers of this book.[B]  \n[A] The price and availability of this board are beyond my control . Please contact Arcom for the latest information. \n[B] No financial or contractual relationship exists between myself  or O'Reilly & Associates, Inc. and Arcom Control Systems. \nI only promote the board here out of thanks to Arcom for produc ing a quality product and supporting me with this project. \nSimply mention the book when placing your orde r and you will be eligible for this special \noffer. To place an order, contact the manufacturer directly at:  \nArcom Control Systems  \n13510 South Oak Street  Kansas City, MO 64145  Phone: 888-941-2224  Fax: 816-941-7807  Email: sales@arcomcontrols.com\n  \nWeb: http://www.arcomcontrols.com/   \nGlossary \nA \nASIC   \nApplication-Specific Integrated Circuit. A piece of custom-designed hardware in a \nchip.  \n \naddress bus   \nA set of electrical lin es connected to the processor  and all of the peripherals  with which it \ncommunicates. The address bus is used by the processor to select a specific memory \nlocation or register  within a particular  peripheral. If the a ddress bus contains n \nelectrical lines, the processor can uni quely address up to 2n such locations.  \n \napplication software   \nProgramming Embedded Systems in C and C++ \n- 162 - Software modules specific to a particular embedded projec t. The application software \nis unlikely to be reusable across em bedded platforms, simply because each embedded \nsystem  has a different application.  \n \nassembler   \nA software development tool th at translates human-readable assembly language  programs \ninto machine-language instructions that the processor  can understand and execute.  \n \nassembly language   \nA human-readable form of a processor's  instruction set. Most processor-specific  functions \nmust be written in assembly language.  \nB \nbinary semaphore   \nA type of semaphore  that has only two st ates. Also called a mutex .  \n \nboard support package   \nPart of a software package that is processor-  or platform-dependent. Typically, sample \nsource code for the board support package is provided by the package developer. The sample code must be modified as necessar y, compiled, and linked w ith the rest of the \nsoftware package.  \n \nbreakpoint   \nA location in a program at which executi on is to be stopped and control of the \nprocessor switched to the debugger . Mechanisms for creating and removing breakpoints \nare provided by most debugging tools.  \nC \nCISC   \nProgramming Embedded Systems in C and C++ \n- 163 - Complex Instruction Set Computer. Describes the architecture of a processor  family . \nCISC processors generally feature variable -length instructions and multiple addressing \nformats, and contain only a small number of general-purpose registers . Intel's 80x86 \nfamily is the quintessential ex ample of CISC. Contrast with RISC.  \n \nCPU   \nCentral Processing Unit. The part of a processor  that executes instructions.  \n \ncompiler   \nA software development tool that translates high-level language  programs into the \nmachine-language instruc tions that a particular processor  can understand and execute.  \n \ncontext   \nThe current state of the registers  and flags of the processor .  \n \ncontext switch   \nThe process of switching from one task to another in a multitasking  operating system. A \ncontext switch i nvolves saving the context  of the running task and restoring the \npreviously saved context of the other. The pi ece of code that does this is necessarily \nprocessor-specific .  \n \ncounting semaphore   \nA type of semaphore  that is used to track multiple resources of the same type. An \nattempt to take a counting semaphore is blocke d only if all of the available resources \nare in use. Contrast with binary semaphore .  \n \ncritical section   \nA block of code that must be executed in sequence and without interruption to \nguarantee correct operation of the software. See also race condition .  \nProgramming Embedded Systems in C and C++ \n- 164 -  \ncross-compiler   \nA compiler  that runs on a different platform than the one for which it produces object \ncode. A cross-compiler runs on a host computer and produces object code for the target .  \nD \nDMA   \nDirect Memory Access. A technique for transferring data di rectly between two \nperipherals  (usually memory and an I/O device) with only minimal intervention by the \nprocessor . DMA transfers are managed by a third peripheral  called a DMA controller.  \n \nDRAM   \nDynamic Random-Access Memory. A type of RA M that maintains its contents only as \nlong as the data stored in the device is refres hed at regular interval s. The refresh cycles \nare usually performed by a peripheral  called a DRAM controller.  \n \nDSP   \nSee digital signal processor .  \n \ndata bus   \nA set of electrical lin es connected to the processor  and all of the peripherals  with which it \ncommunicates. When the processor wants to r ead (or write) the c ontents of a memory \nlocation or register  within a particular pe ripheral, it sets the address bus  pins \nappropriately and receives (or transm its) the contents on the data bus.  \n \ndeadline   \nThe time by which a particular set of computations must be completed. See also \nreal-time system .  \n \nProgramming Embedded Systems in C and C++ \n- 165 - deadlock   \nAn unwanted software situation in which an entire set of tasks is  blocked, waiting for \nan event that only a task within the same se t can cause. If a deadlock occurs, the only \nsolution is to reset the system. However, it  is usually possible to prevent deadlocks \naltogether by following certain  software design practices.  \n \ndebug monitor   \nA piece of embedded software that has been designed specifically for use as a \ndebugging tool. It usually resides in ROM and communicates with a debugger  via a \nserial port or network connection. The debug monitor provides a set of primitive commands to view and modify memory locations and \nregisters , create and remove \nbreakpoints , and execute your program. The debugger combines these primitives to \nfulfill higher-level requests like program download and single-step.  \n \ndebugger   \nA software development tool used to test and debug embedded software. The \ndebugger runs on a host computer and connects to the target  through a serial port or \nnetwork connection. Using a debugger, you can download software to the target for \nimmediate execution. You can also set breakpoints  and examine the contents of specific \nmemory locations and registers .  \n \ndevice driver   \nA software module that hides the details of a particular peripheral  and provides a \nhigh-level programming interface to it.  \n \ndevice programmer   \nA tool for programming nonvolatile memories and other electrically programmable \ndevices. Typically, the programmable device is  inserted into a socket on the device \nprogrammer and the contents of a memory buffer are then transferred into it.  \n \ndigital signal processor   \nProgramming Embedded Systems in C and C++ \n- 166 - A device that is similar to a microprocessor , except that the internal CPU has been \noptimized for use in applications involvi ng discrete-time signal processing. In addition \nto standard microprocessor instructions, DSPs usually support a set of complex \ninstructions to perform common signal-pr ocessing computations quickly. Common \nDSP families are TI's 320Cxx and Motorola's 5600x series.  \nE \nEEPROM   \nElectrically Erasable, Programmable R ead-Only Memory. (Pronounced \"double-E \nPROM.\") A type of PROM  that can be erased electronically.  \n \nEPROM   \nErasable, Programmable Read -Only Memory. A type of PROM  that can be erased by \nexposing it to ultraviolet light. Once eras ed, an EPROM can be reprogrammed with \nthe help of a device programmer .  \n \nembedded system   \nA combination of computer hardware and software, and perhaps additional \nmechanical or other parts, designed to perform a specific function. Contrast with \ngeneral-purpose computer .  \n \nemulator   \nShort for In-Circuit Emulator (ICE). A debugging tool that takes the place \nof-emulates-the processor  on your target  board. Emulators freq uently incorporate a \nspecial \"bond-out\" version of the target processor that allows you to observe and \nrecord its internal state as  your program is executing.  \n \nexecutable   \nA file containing object code  that is ready for execution on the target . All that remains is \nto place the object code into a ROM or download it via a debugging tool.  \nProgramming Embedded Systems in C and C++ \n- 167 - F \nfirmware   \nEmbedded software that is stored as object code  within a ROM. This name is most \ncommon among the programmers of digital signal processors .  \n \nFlash memory   \nA RAM-ROM  hybrid that can be erased and rewr itten under software control. Such \ndevices are divided into blocks, called sect ors, that are individually erasable. Flash \nmemory is common in systems that require nonvolatile data storag e at very low cost. \nIn some cases, a large Flash memory is even used instead of a disk-drive.  \nG \ngeneral-purpose computer   \nA combination of computer hardware and so ftware that serves as a general-purpose \ncomputing platform. For example, a personal computer. Contrast with embedded system .  \nH \nHLL   \nSee high-level language . \n \nheap   \nAn area of memory that is used fo r dynamic memory allocation. Calls to malloc  and free \nand the C++ operators new and delete  result in runtime manipulation of the heap.  \n \nhigh-level language   \nA language, such as C or C++, that is processor-independent . When you program in a \nhigh-level language, it is possible to con centrate on algorithms and applications \nwithout worrying about the details of a particular processor .  \nProgramming Embedded Systems in C and C++ \n- 168 -  \nhost  \nA general-purpose computer  that communicates with the target  via a serial port or network \nconnection. This term is us ually used to distinguish the computer on which the \ndebugger  is running from the embedded system  that is being developed.  \nI \nICE  \nIn-Circuit Emulator. See emulator . \n \nI/O  \nInput/Output. The interface between a processor  and the world around it. The simplest \nexamples are switches (inputs) and LEDs (outputs).  \n \nI/O device   \nA piece of hardware that  interfaces between the processor  and the outside world. \nCommon examples are switches and LEDs, se rial ports, and network controllers.  \n \nI/O map   \nA table or diagram containing the name and address range of each peripheral  \naddressable by the processor  within the I/O space . I/O maps are a helpful aid in getting to \nknow the hardware.  \n \nI/O space   \nA special memory region provided by some processors  and generally reserved for the \nattachment of I/O devices . Memory locations and registers  within an I/O space can be \naccessed only via special instructions. For example, processors in the 80x86 family \nhave special I/O space instructions called in and out. Contrast with memory space .  \n \nProgramming Embedded Systems in C and C++ \n- 169 - ISR  \nSee interrupt service routine . \n \ninstruction pointer   \nA register  in the processor  that contains the address of the next instruction to be executed. \nAlso known as a program counter .  \n \ninterrupt   \nAn asynchronous electr ical signal from a peripheral  to the processor . When the \nperipheral asserts this signal, we say that an  interrupt occurs. When  an interrupt occurs, \nthe current state of the processor is saved and an interrupt service routine  is executed. \nWhen the interrupt service routine exits, co ntrol of the processor is returned to \nwhatever part of the software was previously running.  \n \ninterrupt latency   \nThe amount of time between  the assertion of an interrupt  and the start of the associated \ninterrupt service routine .  \n \ninterrupt service routine   \nA piece of software executed in response to a particular interrupt .  \n \ninterrupt type   \nA unique number associated with each interrupt . \n \ninterrupt vector   \nThe address of an interrupt service routine . \n \nProgramming Embedded Systems in C and C++ \n- 170 - interrupt vector table   \nA table containing interrupt vectors  and indexed by interrupt type . This table contains the \nprocessor's  mapping between interrupts  and interrupt service routines  and must be initialized \nby the programmer.  \n \nintertask communication   \nA mechanism used by tasks and interrupt service routines  to share information and \nsynchronize their access to shared resour ces. The most common building blocks of \nintertask communication are semaphores  and mutexes .  \nL \nlinker   \nA software development tool that accepts one or more object files  as input and outputs a \nrelocatable  program. The linker is thus run afte r all of the source files have been \ncompiled or assembled.  \n \nlocator   \nA software developmen t tool that assigns physical addresses  to the relocatable  program \nproduced by the linker . This is the last step in the pr eparation of software for execution \nby an embedded system , and the resulting file is called an executable . In some cases, the \nlocator's function is hidden within the linker .  \n \nlogic analyzer   \nA hardware debugging tool that can be used to  capture the logic le vels (0 or 1) of \ndozens, or even hundreds, of electrical sign als in real time. Logic analyzers can be \nquite helpful for debugging hardware problems and complex processor-peripheral  \ninteractions.  \n \nM \nmemory map   \nProgramming Embedded Systems in C and C++ \n- 171 - A table or diagram containing the name and address range of each peripheral  \naddressable by the processor  within the memory space . Memory maps are a helpful aid in \ngetting to know the hardware.  \n \nmemory-mapped I/O   \nCommon hardware design methodology in which I/O devices  are placed into the memory \nspace  rather than the I/O space . From the processor's  point of view, memory-mapped I/O \ndevices look very much like memory devices.  \n \nmemory space   \nA processor's  standard address space. Contrast with I/O space .  \n \nmicrocontroller   \nA microcontroller is very similar to a microprocessor . The main difference is that a \nmicrocontroller is designed specifically for use in embedded systems . Microcontrollers \ntypically include a CPU, memory (a small amount of RAM, ROM, or both), and other \nperipherals  on the same chip. Common examples are the 8051, Intel's 80196, and \nMotorola's 68HCxx series.  \n \nmicroprocessor   \nA piece of silicon containing a general-purpose CPU. The most common examples are \nIntel's 80x86 and Motorola's 680x0 families.  \n \nmonitor   \nIn the context of this book, a debug monitor . However, there is a second meaning for this \nword that is associated with intertask communication . In that context, a monitor is a \nlanguage-level synchronization feature.  \n \nmultiprocessing   \nProgramming Embedded Systems in C and C++ \n- 172 - The use of more than one processor  in a single computer system. So-called \n\"multiprocessor systems\" usually have a common memory space  through which the \nprocessors can communicate and share data . In addition, some multiprocessor systems \nsupport parallel processing .  \n \nmultitasking   \nThe execution of multiple software routines in pseudoparallel. Each routine represents \na separate \"thread of execution\" a nd is referred to as a task. The operating system  is \nresponsible for simulating para llelism by parceling out the processor's  time.  \n \nmutex   \nA data structure for mutual exclusion , also known as a binary semaphore . A mutex is \nbasically a multitasking  -aware binary flag that  can be used to protect critical sections  from \ninterruption.  \n \nmutual exclusion   \nA guarantee of exclusive access to a shared resource. In embedded systems , the shared \nresource is typically a block of me mory, a global variable, or a set of registers . Mutual \nexclusion can be achieved with the use of a semaphore  or mutex .  \nN \nNVRAM   \nNonvolatile Random-Access Memory. A type of RAM that retains its data even when \nthe system is powered down. NVRAM frequently consists of an SRAM  and a long-life \nbattery.  \nO \nOTP   \nSee one-time programmable . \n \nProgramming Embedded Systems in C and C++ \n- 173 - object code   \nA set of processor- readable opcodes  and data. The output of compilers , assemblers , linkers , \nand locators  are files containing object code.  \n \nobject file   \nA file containing object code . The output of a compiler  or assembler .  \n \none-time programmable   \nAny programmable device, like a PROM , that can be programmed just once by the end \nuser. However, this term is used  almost exclusively to refer to microcontrollers  that have \non-chip PROM.  \n \nopcode   \nA sequence of bits that is recognized by the processor  as one of the instructions in its \ninstruction set.  \n \noperating system   \nA piece of software that makes multitasking  possible. An operating system typically \nconsists of a set of function calls, or software interrupts , and a periodic clock tick. The \noperating system is responsible for deci ding which task should be using the processor  at \na given time and for controlling access to shared resources.  \n \noscilloscope   \nA hardware debugging tool that allows you to view the voltage on one or more \nelectrical lines. For example, you might us e an oscilloscope to determine if a \nparticular interrupt  is currently asserted.  \nP \nPROM   \nProgramming Embedded Systems in C and C++ \n- 174 - Programmable Read-Only Memory. A type of ROM that can be written (programmed) \nwith a device programmer . These memory devices can be programmed only once, so they \nare sometimes referred to as write-once or one-time programmable  devices.  \n \nparallel processing   \nThe ability to apply two or more processors  to a single computation.  \n \nperipheral   \nA piece of hardware other than the processor, usually memory or an I/O device . The \nperipheral can reside within the same chip as the processor, in which case it is called \nan internal peripheral.  \n \nphysical address   \nThe actual address that is placed on the address bus  when accessing a memory location \nor register .  \n \npreemptive   \nA scheduler  is said to be preemptive if it allows the running task to be suspended when a \nhigher- priority  task becomes ready. Non-preemptive schedulers are easier to implement \nbut less appropriate for embedded systems.  \n \npriority   \nThe relative importance of one task compared to another.  \n \npriority inversion   \nAn unwanted software situation in which a high-priority task is delayed while waiting \nfor access to a shared resource that is not even  being used at the time. For all practical \npurposes, the priority  of this task has been lowe red during the de lay period.  \nProgramming Embedded Systems in C and C++ \n- 175 -  \nprocess   \nA word that is often confused with task or thread . The crucial distinction is that all of \nthe tasks in a system share a common me mory space. Processes, on the other hand, \nalways have their own private memory space. Processes are common in multi-user \nsystems but are rarely, if ever, found in embedded systems .  \n \nprocessor   \nA generic term that does not distinguish between microprocessor , microcontroller , and \ndigital signal processor . I have purposefully used this term throughout the book because \nthe actual processor type has very little impact on the type of embedded software \ndevelopment described here.  \n \nprocessor family   \nA set of related processors , usually successive generations  from the same manufacturer. \nFor example, Intel's 80x86 family began with the 8086 and now includes the 80186, \n286, 386, 486, Pentium, and many others. The later models in a family are typically \nbackwards-compatible with the ones that came before.  \n \nprocessor-independent   \nA piece of software that is independent of the processor  on which it will be run. Most \nprograms that can be written in a high-level language  are processor-indep endent. Contrast \nwith processor-specific .  \n \nprocessor-specific   \nA piece of software that is highly dependent on the processor  on which it will be run. \nSuch code must usually be written in assembly language . Contrast with \nprocessor-independent .  \n \nprofiler   \nProgramming Embedded Systems in C and C++ \n- 176 - A software development tool  that collects and reports execution statistics for your \nprograms. These statistics include the number  of calls to each subroutine and the total \namount of time spent within each. This data can be used to learn which subroutines are \nthe most critical and, therefore, de mand the greatest code efficiency.  \n \nprogram counter   \nSee instruction pointer . \nR \nRAM   \nRandom-Access Memory. A broad classificati on of memory devices that includes all \ndevices in which individual memory locati ons can be read or written as required.  \n \nRISC   \nReduced Instruction Set Computer. Describes the architecture of a processor family . \nRISC processors generally feature fixed-le ngth instructions, a load-store memory \narchitecture, and a large nu mber of general-purpose registers  or register windows. The \nMIPS processor family is an excellent example. Contrast with CISC.  \n \nROM   \nRead-Only Memory. A broad classification of memory devices that includes all \ndevices in which the individual memory lo cations can be read but not written.  \n \nROM emulator   \nA debugging tool that takes the place of-or emulates-the ROM on your target  board. A \nROM emulator acts very much like a debug monitor , except that it includes its own \nserial or network connection to the host.  \n \nROM monitor   \nProgramming Embedded Systems in C and C++ \n- 177 - See debug monitor . \n \nRTOS   \nReal-Time Operating System. An operating system  designed specifically for use in \nreal-time systems .  \n \nrace condition   \nA situation in which the outcome of a progr am can be affected by the exact order in \nwhich the instructions are executed. R ace conditions are only an issue where interrupts  \nand/or preemption  are possible and where critical sections  exist.  \n \nreal-time system   \nAny computer system, embedde d or otherwise, that has deadlines . The following \nquestion can be used to identif y real-time systems: is a late  answer as bad as, or even \nworse than, a wrong answer? In other words, what happens if the computation doesn't \nfinish in time? If nothing bad happens, it's not a real-time system. If someone dies or \nthe mission fails, it's generally considered \"hard\" real-time, which is meant to imply \nthat the system has \"hard\" deadlines. Ever ything in between is \"soft\" real-time.  \n \nrecursive   \nRefers to software that calls itself. Recu rsion should generally be avoided in an \nembedded system  because it frequently requires a large stack.  \n \nreentrant   \nRefers to software that can be executed multiple times simultaneously. A reentrant \nfunction can be safely called recursively  or from multiple tasks. The key to making code \nreentrant is to ensure mutual exclusion  whenever accessing global variables or shared \nregisters .  \n \nregister   \nProgramming Embedded Systems in C and C++ \n- 178 - A memory location that is part of a processor  or a peripheral . In other words, it's not \nnormal memory. Generally, each bit or set of bits within the register controls some \nbehavior of the larger device.  \n \nrelocatable   \nA file containing object code  that is almost ready for execution on the target . The final \nstep is to use a locator  to fix the remaining relocatable  addresses within the code. The \nresult of that process is an executable .  \n \nreset address   \nThe address from which the first instruction will be fetched after the processor  is \npowered on or reset.  \n \nreset code   \nA small piece of code that is placed at the reset address . The reset code is usually \nwritten in assembly language  and might simply be the equivalent of \"jump to the startup \ncode.\"  \n \nreset vector   \nSee reset address . \nS \nSRAM   \nStatic Random-Access Memory. A type of RAM that retains its contents as long as \npower is supplied to it. Data stored in an SRAM is lost when the system is powered \ndown or reset.  \n \nscheduler   \nProgramming Embedded Systems in C and C++ \n- 179 - The part of an operating system  that decides which task to run next. This decision is based \non the readiness of each task, their relative priorities , and the specific scheduling \nalgorithm implemented.  \n \nsemaphore   \nA data structure that is used for intertask communication . Semaphores are usually \nprovided by the operating system .  \n \nsimulator   \nA debugging tool that runs on the host and pretends to be the target  processor . A \nsimulator can be used to test pieces of th e software before the embedded hardware is \navailable. Unfortunately, attempts to simulate interactions with complex peripherals  are \noften more trouble than they are worth.  \n \nsoftware interrupt   \nAn interrupt  that is generated by a software instruction. Software interrupts are \ncommonly used to implement breakpoints  and operating system  entry points. Compare \nwith trap.  \n \nstack   \nAn area of memory that contains a last-in- first-out queue of storage for parameters, \nautomatic variables, return addresses, and other information that must be maintained \nacross function calls. In multitasking  situations, each task generally has its own stack.  \n \nstack frame   \nAn area of the stack associated with a part icular function call.  \n \nstartup code   \nProgramming Embedded Systems in C and C++ \n- 180 - A piece of assembly language  code that prepares the wa y for software written in a \nhigh-level language . Most C/C++ cross-compilers  come with startup code that you can \nmodify, compile, and link with  your embedded programs.  \nT \ntarget   \nAnother name for the embedded system . This term is usually used during software \ndevelopment, to distinguish the embedded system from the host with which it \ncommunicates.  \n \ntask  \nThe central abstraction of an operating system . Each task must maintain its own copy of \nthe instruction  pointer  and general-purpose registers . Unlike processes , tasks share a \ncommon memory space and must be careful to avoid overwriting each other's code \nand data.  \n \nthread   \nAnother name for a task. This name is more common in operating systems  that support \nprocesses . A task is simply a thread in a single-process system.  \n \ntracepoint   \nSimilar to a breakpoint  except that a counter is increm ented rather than stopping the \nprogram. Tracepoints are not supported by all debugging tools.  \n \ntrap  \nAn interrupt that is generated by the processor's  own internal hardware. For example, \nthe processor might trap if an illegal opcode  is found in your program. Compare with \nsoftware interrupt .  \nV \nProgramming Embedded Systems in C and C++ \n- 181 - volatile   \nA value that can change without  the intervention of software is said to be volatile. For \nexample, values within the registers  of some I/O devices  change in response to external \nevents. C's volatile  keyword should be used to warn your compiler  about any pointers \nthat point to such registers. This will ensu re that the actual value is reread each time \nthe data is used.  \nW \nwatchdog timer   \nA hardware timer that is pe riodically reset by software. If the software crashes or \nhangs, the watchdog timer will expire, and the entire syst em will be reset \nautomatically.  \nProgramming Embedded Systems in C and C++ \n- 182 - Bibliography \nOne of the most frustrating aspects of devel oping embedded software is that there are few \nreferences available. Many of the books that have  been written are poor or out of print, and \nthere are only a handful of peri odicals dedicated to the subject. What follows is an annotated \nlist of the books, magazines, and other resour ces I found most helpful in writing this book. \nThis is not an attempt to itemize all of the rele vant publications. In fact, I have specifically \nomitted several books and magazines that did not impress me. What's left is a list of books worth owning, magazines and conferences worthy  of your time, and Wo rld Wide Web sites \nworth bookmarking.  \n12.1 Books \nBall, Stuart R. Embedded Microprocessor Systems: Real World Design . Newton, Mass.: Butterworth-Heinemann, \n1996.   \nThis tiny book is packed full of information about hardware design and embedded \nsystem development that every embedded so ftware engineer should understand to be \neffective.  \nBrown, John Forrest. Embedded Systems Programming in C and Assembly.  New York: Van Nostrand Reinhold, \n1994.   \nIt's a good thing I didn't know about this book a few years ago. If I had, I might not \nhave tried writing my own. It is obvious to me that Mr. Brown and I had similar \nvisions for our books. And since I have tried to stay away from assembly language as \nmuch as possible, this book would make an excellent companion to the one you are \nreading.  \nGanssle, Jack G. The Art of Programming Embedded Systems . San Diego: Academic Press, 1992.   \nSome very practical advice from one of our industry's most vocal gurus. The author of \na monthly column in Embedded Systems Programming  (described later in this bibliography), \nMr. Ganssle has helpfully collected some of his most lasting tips a nd rules of thumb in \nthis book. A handy reference for topics that are too specific to be covered here.  \nKernighan, Brian W., and Dennis M. Ritchie. The C Programming Language . Englewood Cliffs, N.J.: \nPrentice-Hall, 1988.   \nA concise explanation of C's syntax and se mantics direct from the founding fathers. A \nnecessary component of any programmer's bookshelf.  \nLabrosse, Jean J. µC/OS: The Real-Time Kernel . Lawrence, Kans.: R & D Publications, 1992.   \nProgramming Embedded Systems in C and C++ \n- 183 - A real-time operating system with source code and explanatory text-all for the price of \na book. A great investment for someone who's thinking of writing their own operating system, or just looking for free source code. µC/OS (pronounced \"micro-COS\") has \nbeen ported to many processors and has a large user base.  \nRosenberg, Jonathan B. How Debuggers Work: Algorithms, Data Structures, and Architecture . New York: John P. \nWiley & Sons, 1996.   \nIf you've ever wondered what a debugger looks  like on the inside, this book is for you. \nIt will also give you a better understa nding of the split between debugger and debug \nmonitor and the potential fo r interference between the debugger and your programs.  \nSatir, Gregory, and Doug Brown. C++: The Core Language . Cambridge, Mass.: O'Reilly & Associates, 1995.   \nAn excellent introduction to C++ for comp etent C programmers. If you don't already \nhave a C++ book that you like, try this one.  \nVan der Linden, Peter. Expert C Programming: Deep C Secrets . Englewood Cliffs, N.J. : Prentice-Hall, 1994.   \nWritten by a member of Sun Microsystems ' compiler development team, this book \nhelps to fill the gaps in knowledge betw een an ordinary C programmer and a guru. \nAlthough not entirely necessary, an understand ing of these advanced topics can only \nmake you a better embedded programmer. This book is an excellent reference as well \nas an entertaining read.  \nVan Sickle, Ted. Programming Microcontrollers in C . Solana Beach, Calif.: HighText Publications, 1994.   \nLike many of the embedded programming books th at I've found, this one is specific to \na particular processor family. Howeve r, because the book is well written and \nMotorola's microcontrollers are quite popular, some readers will still find it useful.  \n12.2 Magazines and Conferences \nEmbedded Systems Programming   \nA monthly publication devoted specifically to the issues embedded software developers face \non the job. Every article and column is packed with practical advice and written in a casual \nstyle familiar to readers of this and other Nutshell Ha ndbooks. I highly recommend that \neveryone reading this sentence immediately put my book down a nd take a few minutes to sign \nup for a free subscription at http://www.embedded.com/mag.shtml . It usually takes several months \nto get going, but is well worth the wait.  \nIn addition, you might want to purchase a copy of the CD-ROM archive. This searchable \ndatabase contains hundreds of pa st articles and columns and was an indispensable reference in \nthe creation of this book. More information is available at http://www.embedded.com/cd.htm .  \nProgramming Embedded Systems in C and C++ \n- 184 - Embedded Systems Conference   \nA technical conference hosted several ti mes each year by the publishers of the \nmagazine just described. The conference ha s been running for about 10 years, and the \nnumber of exhibitors and attendees continue s to grow each year. The knowledge to be \ngained here far outweighs the cost of tr aveling to the conference and attending the \nclasses. I try to go as often as I can.  \n12.3 World Wide Web \nChip Directory ( http://www.hitex.com/ )  \nAn unbelievably large collection of information about common processors and \nperipherals. This is not the only such s ite on the Web, but it is one of the best \nmaintained and it has links to many of the others.  \nCPU Info Center ( http://bwrc.eecs.berkeley.edu/CIC/ )  \nTons of information about new and old processors alike. Includes a section \nspecifically about common embedded processors.  \nCRC Pitstop ( http://www.ross.net/crc/ )  \nA site dedicated to information about  CRC implementation, including Ross Williams' \n\"Painless Guide to CRC Error Detection Algor ithms.\" The latter is the most readable \nexplanation of CRC calculations I've ever found.  \nElectronic Engineers' Toolbox ( http://www.eetoolbox.com/ebox.htm )  \nFocused on embedded systems, real-time software development issues, and \nInternet-enabling tec hnologies, the \"EE Toolbox\" is desi gned to make your job easier. \nThe publishers of this site have identifi ed, indexed, and summarized thousands of \nrelevant Internet resources and brought them all together in one place.  \nEmbedded Intel Architecture ( http://www.intel.com/design/intarch/ )  \nIntel's home page for their embedded pr ocessor line, includ ing the 80188EB. In \naddition to technical information about the hardware, there are also free development \nand debugging tools and example source code listings.  \nnews:comp.arch.embedded   \nA newsgroup devoted to many of the topi cs discussed in this book. Discussions \nfrequently involve software developmen t tools and processes, comparisons of \nProgramming Embedded Systems in C and C++ \n- 185 - commercial real-time operating systems, and suggestions for processor selection \ncriteria.  \nnews:comp.realtime   \nAnother good newsgroup for embedded system s discussion. This one tends to focus \nmore heavily on real-time scheduling issues, however, so not all of the information is \nrelevant. A list of FAQs from this group can be found at \nhttp://www.faqs.org/faqs/by-news group/comp/comp.realtime.html .  \nProgramming Embedded Systems in C and C++ \n- 186 - Colophon \nOur look is the result of reader comments, our own experimentation, and feedback from \ndistribution channels. Distinctive covers comple ment our distinctive approach to technical \ntopics, breathing personality and li fe into potentially dry subjects. \nThe insects on the cover of Programming Embedded Systems in C and C++  are ticks. There \nare approximately 850 species of these sma ll to microscopic, blood-feeding parasites \ndistributed worldwide. They are particularly abundant in trop ical and subtropical regions. \nThere are two main families of ticks: hard tick s, whose mouth parts are visible from above, \nand soft ticks, whose mouth parts are hidden. \nIn both hard and soft ticks, the mouth is ma de up of three major pa rts: the palps, the \nchelicerae, and the hypostome. It is the hypostome that is inserted into the host's skin while \nthe tick is feeding. A series of backward-faci ng projections on the hypostome make it difficult \nto remove the tick from the skin. Most ticks al so secrete a sticky subs tance that glues them \ninto place. This substance dissolves when the tick is done feeding. Their external body surface \nexpands from 200 to 600 percent to acco mmodate the blood that is ingested. \nTicks go through three life stages: larva, nymph, and adult. At each stage they feed on a \nmammal, reptile, or bird host. Ticks wait for a host by perching on leaves or other surfaces \nwith their front two legs extended. When a hos t brushes up against them they latch on and \nattach themselves. Adult female hard ticks lay a single batch of thousands of eggs and then \ndie. Adult male ticks also  die after a single mating. \nAs parasites go, ticks can be very nasty. Th ey transmit more dis ease than any other \nblood-sucking parasite, including Lyme disease, Rocky Mountain spotted fever, and relapsing \nfever. They can also cause excessive blood loss.  Some ticks secrete ne rve poisons that can \npotentially cause death. A tick can be removed from skin by grasping it with a tweezer or a \nspecial tick-removing device as cl ose to the skin as possible, and pulling in one steady motion. \nDo not squeeze the tick. Immediately flush it down the toilet-or place it in  a sealed container \nand hold onto it for one month, in case you develop symptoms of a disease. \nMelanie Wang was the production editor and proofreader for Embedded Programming \nSystems in C and C++ . Sheryl Avruch was the production manager; Paulette A. Miley was \nthe copy editor; Nancy Kotary and Madeleine Ne well provided quality c ontrol. Seth Maislin \nwrote the index. \nEdie Freedman designed the cover of this book, using a 19th-century engraving from the \nDover Pictorial Archive. The cover layout wa s produced with QuarkXPress 3.3 using the ITC \nGaramond font. \nProgramming Embedded Systems in C and C++ \n- 187 - The inside layout was designed by Edie Freedman and implemented in FrameMaker by Mike \nSierra. The text and heading fonts are ITC Garamond Light and Garamond Book. The \nillustrations that appear in the book were cr eated in Macromedia Freehand 7.0 by Robert \nRomano. This colophon was written by Clairemarie Fisher O'Leary.",
    "chapter includes": "source c ode implementations of memo ry tests and Flash memory \ndrivers.  \n•",
    "chapter number": "and include build \ninstructions (makefiles) to help  you recreate each of the executables. The complete archive is \navailable via FTP, at ftp://ftp.oreilly.com/pub/examples/nutshell/embedded_c/ .  \nHow to Contact Us \nWe have tested and verified all the informati on in this book to the best of our ability, but you \nmay find that features have changed (or even that we have made mi stakes!). Please let us \nknow about any errors you find, as well as your s uggestions for future editions, by writing to:  \nO'Reilly & Associates  \n1005 Gravenstein Highway North  Sebastopol, CA 95472  800-998-9938 (in the U.S. or Canada)  707-829-0515 (international/local)  707-829-0104 (FAX)  \nYou can also send us messages electronically. To be put on the mailing list or request a \ncatalog, send email to:  \ninfo@oreilly.com   \nTo ask technical questions or comment on the book, send email to: \nbookquestions@oreilly.com   \nWe have a web site for the book, where we'll list  examples, errata, and any plans for future \neditions. You can access this page at:  \nhttp://www.oreilly.com/catalog/embsys/   \nFor more information about this book and others, see the O'Reilly web site:  \nhttp://www.oreilly.com   \nProgramming Embedded Systems in C and C++ \n- 10 - Personal Comments and Acknowledgments \nAs long as I can remember I have been intere sted in writing a book or two. But now that I \nhave done so, I must confess that I was naive when I started. I had no idea how much work it \nwould take, nor how many other people would have to get involved. Another thing that \nsurprised me was how easy it was to find a willi ng publisher. I had expected that to be the \nhard part.  \nFrom proposal to publication, this project has ta ken almost two years to complete. But, then, \nthat's mostly because I worked a full-time job throughout and tried to maintain as much of my \nsocial life as possible. Had I known when I star ted that I'd still be agonizing over final drafts \nat this late date, I would have probably quit working and finished the book more quickly. But \ncontinuing to work has been good for the book (a s well as my bank account!). It has allowed \nme the luxury of discussing my ideas regularly  with a complete cast of embedded hardware \nand software professionals. Many of these same folks have also contributed to the book more \ndirectly by reviewing drafts of some or all of the chapters.  \nI am indebted to all of the following people fo r sharing their ideas a nd reviewing my work: \nToby Bennett, Paul Cabler (and the other great fo lks at Arcom), Mike Corish, Kevin D'Souza, \nDon Davis, Steve Edwards, Mike Ficco, Barbar a Flanagan, Jack Ganssle, Stephen Harpster \n(who christened me \"King of the Sentence Fragme nt\" after reading an ea rly draft), Jonathan \nHarris, Jim Jensen, Mark Kohler, Andy Kollegge r, Jeff Mallory, Ian Miller, Henry Neugauss, \nChris Schanck, Brian Silverman, John Snyder, Jason Steinhorn (whose constant stream of \ngrammatical and technical critiques have made  this book worth reading), Ian Taylor, Lindsey \nVereen, Jeff Whipple, and Greg Young.  \nI would also like to thank my editor, Andy Oram. Without his enthusiasm for my initial \nproposal, overabundant patience, and constant encouragement, this book would never have \nbeen completed.  \nFinally, I'd like to thank Alpa Dharia for he r support and encouragement throughout this long \nprocess.  \nMichael Barr mbarr@netrino.com  \nProgramming Embedded Systems in C and C++ \n- 11 -",
    "chapter we": "'ll discuss the most \ncommon software issues that arise when inte rfacing to a peripheral of either type.  \n7.1 Control and Status Registers \nThe basic interface between an embedded processo r and a peripheral device is a set of control \nand status registers. These registers are part of the peripheral hardwa re, and their locations, \nsize, and individual meanings are features of th e peripheral. For example,  the registers within \na serial controller are very different from those in a timer/counter. In this section, I'll describe \nhow to manipulate the contents of  these control and status regi sters directly from your C/C++ \nprograms.  \nDepending upon the design of the processor and boar d, peripheral devices ar e located either in \nthe processor's memory space or within the I/O space. In fact, it is common for embedded \nsystems to include some peripherals of each  type. These are called memory-mapped and \nI/O-mapped peripherals, respectiv ely. Of the two types, memory-mapped peripherals are \ngenerally easier to work with  and are increasingly popular.  \nMemory-mapped control and status registers can be made to look ju st like ordinary variables. \nTo do this, you need simply declare a pointer to the register, or block of  registers, and set the \nvalue of the pointer explicitly. For ex ample, if the P2LTCH register from",
    "chapter contains": "only  the source code for this first program. We'll \ndiscuss how to create the executable and actually  run it in the two chapters that follow.  \n2.1 Hello, World! \nIt seems like every programming book ever wri tten begins with the same example-a program \nthat prints \"Hello, World!\" on the user's scr een. An overused example like this might seem a \nbit boring. But it does help reader s to quickly assess the ease or  difficulty with which simple \nprograms can be written in the programming e nvironment at hand. In that sense, \"Hello, \nWorld!\" serves as a useful benchmark of programming languages and computer platforms. \nUnfortunately, by this measure, embedded syst ems are among the most difficult computer \nplatforms for programmers to work with. In  some embedded systems, it might even be \nimpossible to implement the \"Hello, World!\" prog ram. And in those systems that are capable \nof supporting it, the printi ng of text strings is usually more  of an endpoint than a beginning.  \nYou see, the underlying assumption of the \"Hello, World!\" example is that there is some sort \nof output device on which strings of characters can be printe d. A text window on the user's \nmonitor often serves that purpose. But most embedded systems lack a monitor or analogous \noutput device. And those that do have one t ypically require a special piece of embedded \nsoftware, called a display driver, to be implem ented first-a rather ch allenging way to begin \none's embedded programming career.  \nIt would be much better to begin with a small, easily implemented, and highly portable \nembedded program in which there is little r oom for programming mistakes. After all, the \nreason my book-writing count erparts continue to use the \"Hell o, World!\" example is that it is \na no-brainer to implement. This eliminates one of  the variables if the reader's program doesn't \nwork right the first time: it isn't a bug in their code; rather, it is a problem with the \ndevelopment tools or process that they us ed to create the executable program.  \nEmbedded programmers must be self-reliant. They  must always begin each new project with \nthe assumption that nothing works-that all they  can rely on is the basic syntax of their \nProgramming Embedded Systems in C and C++ \n- 23 - programming language. Even the standard librar y routines might not be available to them. \nThese are the auxiliary functions-like printf  and scanf - that most other programmers take for \ngranted. In fact, library routines are often as much a part of th e language standard as the basic \nsyntax. However, that part of the standard is more difficult to s upport across all possible \ncomputing platforms and is occasionally ignored by the makers of compilers for embedded \nsystems.  \nSo you won't find an actual \"Hello, World!\" program in this chapter. Instead, we will assume only the basic \nsyntax of C is available for our first example. As we progress through the book, we will gradually add C++ \nsyntax, standard library routines, and the equivalent of a character output device to our repertoire. Then, in",
    "chapter and": "the next I'll be using the GNU tools (comp iler, assembler, linker, and \ndebugger) as examples. These tools are ex tremely popular with embedded software \ndevelopers because they are freely available (even the source code is free) and support many \nof the most popular embedded processors. I will use features of these specific tools as \nillustrations for the general concepts discussed. Once understood, these same basic concepts \ncan be applied to any equivalent development tool.  \n3.2 Compiling \nThe job of a compiler is mainly to transl ate programs written in some human-readable \nlanguage into an equivalent set of opcodes for a particular processor. In that sense, an \nassembler is also a compiler (you might call it an \"assembly language compiler\") but one that \nperforms a much simpler one-to-one translatio n from one line of human-readable mnemonics \nto the equivalent opcode. Everything in th is section applies equally to compilers and \nassemblers. Together these tools make up the first step of the embedded software build \nprocess.  \nOf course, each processor has its own unique machine language, so you need to choose a \ncompiler that is capable of producing programs for your specific target processor. In the \nembedded systems case, this compiler almost al ways runs on the host computer. It simply \ndoesn't make sense to execute the compiler on the embedded system itself. A compiler such as this-that runs on one computer platform a nd produces code for another-is called a \ncross-compiler. The use of a cross-compiler is  one of the defining features of embedded \nsoftware development.  \nThe GNU C/C++ compiler (  gcc ) and assembler ( as ) can be configured as either native \ncompilers or cross-compilers. As cross-compile rs these tools support an impressive set of \nhost-target combinations. \nTable 3-1  lists some of the most popular of the supported hosts and \nProgramming Embedded Systems in C and C++ \n- 31 - targets. Of course, the selections of host plat form and target processor are independent; these \ntools can be configured for any combination.  \nTable 3-1. Hosts and Targets Supported by the GNU Compiler  \nHost Platforms Target Processors \nDEC Alpha Digital Unix  \nHP 9000/700 HP-UX  \nIBM Power PC AIX  IBM RS6000 AIX  \nSGI Iris IRIX  \nSun SPARC Solaris Sun SPARC SunOS  \nX86 Windows 95/NT  \nX86 Red Hat Linux AMD/Intel x86 (32-bit only) \nFujitsu SPARClite  \nHitachi H8/300, H8/300H, H8/S  Hitachi SH  \nIBM/Motorola PowerPC  \nIntel i960  MIPS R3xxx, R4xx0  \nMitsubishi D10V, M32R/D  \nMotorola 68k  Sun SPARC, MicroSPARC Toshiba TX39 \nRegardless of the input language (C/C++, asse mbly, or any other), the output of the \ncross-compiler will be an object file. This is a sp ecially formatted binary file that contains the \nset of instructions and data resulting from th e language translation proc ess. Although parts of \nthis file contain executable code, the object file is not intended to be executed directly. In fact, \nthe internal structure of an obj ect file emphasizes the incompleteness of the larger program.  \nThe contents of an object file can be thought of as a very large, flexible data structure. The \nstructure of the file is usually defined by a standard format like the Common Object File \nFormat (COFF) or Extended Linker Format (ELF ). If you'll be using more than one compiler \n(i.e., you'll be writing parts of your program in different source languages), you need to make \nsure that each is capable of producing obj ect files in the same format. Although many \ncompilers (particularly those th at run on Unix platforms) suppor t standard object file formats \nlike COFF and ELF (  gcc supports both), there are also so me others that produce object files \nonly in proprietary formats. If you're using one of the compilers in the latter group, you might \nfind that you need to buy all of your othe r development tools from the same vendor.  \nProgramming Embedded Systems in C and C++ \n- 32 - Most object files begin with a header that desc ribes the sections that follow. Each of these \nsections contains one or more bl ocks of code or data that orig inated within the original source \nfile. However, these blocks have been regr ouped by the compiler into related sections. For \nexample, all of the code blocks are collected into a section called text , initialized global \nvariables (and their initial values) into a section called data , and uninitialized global variables \ninto a section called bss.  \nThere is also usually a symbol table somewhere in the object file that contains the names and \nlocations of all the variables and functions referenced within the s ource file. Parts of this table \nmay be incomplete, however, because not all of the variables and functions are always \ndefined in the same file. These are the symbols that refer to va riables and functions defined in \nother source files. And it is up to the linke r to resolve such unresolved references.  \n3.3 Linking \nAll of the object files resulting from step one must be combined in a special way before the \nprogram can be executed. The object files th emselves are individually incomplete, most \nnotably in that some of the internal variab le and function referenc es have not yet been \nresolved. The job of the linker is to combine th ese object files and, in th e process, to resolve \nall of the unreso lved symbols.  \nThe output of the linker is a new object file that  contains all of the c ode and data from the \ninput object files and is in the same object  file format. It does this by merging the text , data , \nand bss sections of the input files. So, when the linker is finished executing, all of the \nmachine language code from all of th e input object file s will be in the text  section of the new \nfile, and all of the initialized and uniniti alized variables will reside in the new data  and bss \nsections, respectively.  \nWhile the linker is in the proce ss of merging the section contents , it is also on the lookout for \nunresolved symbols. For example, if one object file contains an unresolved reference to a \nvariable named foo and a variable with that same name is declared in one of the other object \nfiles, the linker will match them up. The unr esolved reference will be replaced with a \nreference to the actual variable. In other words, if foo is located at offset 14 of the output data \nsection, its entry in the symbol tabl e will now contain that address.  \nThe GNU linker ( ld ) runs on all of the same host platforms as the GNU compiler. It is \nessentially a command-line tool that takes the names of all the object files to be linked \ntogether as arguments. For embedded developmen t, a special object file that contains the \ncompiled startup code must also be  included within this list. (See Startup Code  later in this \nchapter.) The GNU linker also has a scripting lang uage that can be used to exercise tighter \ncontrol over the object file that is output.  \nProgramming Embedded Systems in C and C++ \n- 33 - Startup Code \nOne of the things that traditional software  development tools do automatically is to \ninsert startup code. Startup code is a sm all block of assembly language code that \nprepares the way for the execution of soft ware written in a high-level language. \nEach high-level language has its own se t of expectations about the runtime \nenvironment. For example, C and C++ both utilize an implicit stack. Space for the \nstack has to be allocated a nd initialized before software  written in either language \ncan be properly executed. That is just one of the responsibilities assigned to startup \ncode for C/C++ programs.  \nMost cross-compilers for embedded system s include an assembly language file \ncalled startup.asm,  crt0.s  (short for C runtime), or something similar. The location \nand contents of this file are usually desc ribed in the documenta tion supplied with the \ncompiler.  \nStartup code for C/C++ programs usually  consists of the following actions, \nperformed in the order described:  \n1. Disable all interrupts. \n2. Copy any initialized data from ROM to RAM. \n3. Zero the uninitialized data area. \n4. Allocate space for and initialize the stack.  \n5. Initialize the processor's stack pointer. \n6. Create and initialize the heap. \n7. Execute the constructors and initializ ers for all global variables (C++ only). \n8. Enable interrupts. \n9. Call main . \nTypically, the startup code will also incl ude a few instructions after the call to main . \nThese instructions will be executed only in the event that th e high-level language \nprogram exits (i.e., the call to main  returns). Depending on the nature of the \nembedded system, you might want to use thes e instructions to halt the processor, \nreset the entire system, or tran sfer control to a debugging tool.  \nBecause the startup code is not inserted automatically, the programmer must usually \nassemble it himself and include the resulting object file among the list of input files \nto the linker. He might even  need to give the linker a special command-line option \nto prevent it from inserting the usual startup code. Working startup code for a \nvariety of target processors can be found in a GNU package called libgloss .  \nIf the same symbol is declared in more than one  object file, the linker is unable to proceed. It \nwill likely appeal to the programmer-by displa ying an error message-and exit. However, if a \nProgramming Embedded Systems in C and C++ \n- 34 - symbol reference instead remains unresolved afte r all of the object files have been merged, \nthe linker will try to resolve the reference on its own. The reference might be to a function \nthat is part of the standard lib rary, so the linker will open each of the libraries described to it \non the command line (in the order provided) and examine their symbol tables. If it finds a \nfunction with that name, the reference will be resolved by including the associated code and \ndata sections within the output object file.[2]  \n[2] Beware that I am only talking about static linking here. In no n-embedded environments, dynamic linking of libraries is very \ncommon. In that case, the code and data associated with the lib rary routine are not inserted into the program directly. \nUnfortunately, the standard libra ry routines often require some  changes before they can be \nused in an embedded program. The problem here is that the standard libraries provided with \nmost software development tool suites arrive only in object form. So you only rarely have \naccess to the library source code to make th e necessary changes yourself. Thankfully, a \ncompany called Cygnus has created a freeware vers ion of the standard C library for use in \nembedded systems. This package is called newlib . You need only download the source code \nfor this library from the Cygnus web site, im plement a few target-specific functions, and \ncompile the whole lot. The library can then be linked with your embedded software to resolve \nany previously unresolved standard library calls.  \nAfter merging all of the code and data sections and resolving all of the symbol references, the \nlinker produces a special \"relocat able\" copy of the program. In other words, the program is \ncomplete except for one thing: no memory addres ses have yet been assigned to the code and \ndata sections within. If you weren't working on an embedded system, you'd be finished \nbuilding your software now.  \nBut embedded programmers aren't generally fini shed with the build process at this point. \nEven if your embedded system includes an ope rating system, you'll probably still need an \nabsolutely located binary image. In fact, if th ere is an operating system, the code and data of \nwhich it consists are most likely within the relocatable program t oo. The entire embedded \napplication-including the operati ng system-is almost always st atically linked together and \nexecuted as a single binary image.  \n3.4 Locating \nThe tool that performs the conversion from relo catable program to executable binary image is \ncalled a locator. It takes responsibil ity for the easiest step of the th ree. In fact, you will have to \ndo most of the work in this step yourself, by providing information about the memory on the \ntarget board as input to the locator. The loca tor will use this information to assign physical \nmemory addresses to each of the code and data sections within the relocatable program. It will \nthen produce an output file that contains a bina ry memory image that can  be loaded into the \ntarget ROM.  \nProgramming Embedded Systems in C and C++ \n- 35 - In many cases, the locator is a separate deve lopment tool. However, in the case of the GNU \ntools, this functionality is built right into th e linker. Try not to be confused by this one \nparticular implementation. Whet her you are writing software fo r a general-purpose computer \nor an embedded system, at some point the sect ions of your relocatable program must have \nactual addresses assigned to them. In the firs t case, the operating system does it for you at \nload time. In the second, you must perform the step with a special tool. This  is true even if the \nlocator is a part of the linker,  as it is in the case of ld.  \nThe memory information required by the GNU li nker can be passed to it in the form of a \nlinker script. Such scripts are sometimes used to  control the exact order of the code and data \nsections within the relocatable program. But here , we want to do more than just control the \norder; we also want to establish the location of each section in memory.  \nWhat follows is an example of a linker script  for a hypothetical embedded target that has 512 \nKB each of RAM and ROM:  \nMEMORY \n{     ram : ORIGIN = 0x00000, LENGTH = 512K     rom : ORIGIN = 0x80000, LENGTH = 512K }  SECTIONS {     data ram :                          /* Initialized data.         */      {          _DataStart = . ;          *(.data)          _DataEnd   = . ;      } >rom      bss :                               /* Uninitialized data.       */     {          _BssStart = . ;         *(.bss)          _BssEnd   = . ;     }      _BottomOfHeap = . ;                 /* The heap starts here.     */     _TopOfStack = 0x80000;              /* The stack ends here.      */      text rom :                          /* The actual instructions.  */     {          *(.text)  \nProgramming Embedded Systems in C and C++ \n- 36 -  \n    } }\n \nThis script informs the GNU linker's built-in lo cator about the memory on the target board \nand instructs it to locate the data  and bss sections in RAM (star ting at address 0x00000) and \nthe text  section in ROM (starting at 0x80000). However,  the initial values of the variables in \nthe data  segment will be made a part of the ROM image by the addition of >rom  at the end of \nthat section's definition.  \nAll of the names that begin with underscores ( _TopOfStack , for example) are variables that \ncan be referenced from within your source code . The linker will use thes e symbols to resolve \nreferences in the input object files. So, for example, there might be a part of the embedded \nsoftware (usually within the startup code) that  copies the initial values of the initialized \nvariables from ROM to the data  section in RAM. The start and stop addresses for this \noperation can be established symbolicall y, by referring to the integer variables _DataStart  \nand _DataEnd  .  \nThe result of this final step of the build proces s is an absolutely located binary image that can \nbe downloaded to the embedded system or progr ammed into a read-only memory device. In \nthe previous example, this memory image woul d be exactly 1 MB in size. However, because \nthe initial values for th e initialized data secti on are stored in ROM, the lower 512 kilobytes of \nthis image will contain only zeros, so only the up per half of this image is significant. You'll \nsee how to download and execute such me mory images in the next chapter.  \n3.5 Building das Blinkenlights \nUnfortunately, because we're using the Arcom bo ard as our reference platform, we won't be \nable to use the GNU tools to build the examples. Instead we'll be using Borland's C++ Compiler and Turbo Assembler. These tools can be run on any DOS or Windows-based PC.\n[3] \nIf you have an Arcom board to experiment w ith, this would be a good time to set it up and \ninstall the Borland development tools on your host computer. (See Appendix A  for ordering \ninformation). I used version 3.1 of the co mpiler, running on a Windows 95-based PC. \nHowever, any version of the Borland tools th at can produce code for the 80186 processor will \ndo.  \n[3] It is interesting to note that Borland's C++ compiler was not specifically designed for use by embedded software developers. \nIt was instead designed to produce DOS and Windows-based progra ms for PCs that had 80x86 processors. However, the inclusion \nof certain command-line options allows us to specify a particul ar 80x86 processor-the 80186, for example-and, thus, use this \ntool as a cross-compiler for embedded systems like the Arcom bo ard. \nAs I have implemented it, the Blinking LED example consists of three source modules: led.c, \nblink.c , and startup.asm . The first step in the build process is to compile these two files. The \ncommand-line options we'll need are -c for \"compile, but don't link,\" -v for \"include symbolic \nProgramming Embedded Systems in C and C++ \n- 37 - debugging information in the output,\" -ml for \"use the large memory model,\" and -1 for \"the \ntarget is an 80186 processor.\" He re are the actual commands:  \nbcc -c -v -ml -1 led.c \nbcc -c -v -ml -1 blink.c  \nOf course, these commands will work only if the bcc.exe  program is in your PATH and the \ntwo source files are in the cu rrent directory. In other wo rds, you should be in the Chapter2  \nsubdirectory. The result of each of these commands  is the creation of an object file that has \nthe same prefix as the .c file and the extension .obj. So if all goes well, there will now be two \nadditional files- led.obj  and blink.obj - in the working directory.  \nAlthough it would appear that there are only these two object files to  be linked together in our \nexample, there are actually three. That's because  we must also include some startup code for \nthe C program. (See Startup Code  earlier in this chapter.) Example startup code for the Arcom \nboard is provided in the file startup.asm , which is included in the Chapter3  subdirectory. To \nassemble this code into an object file, cha nge to that directory and issue the following \ncommand:  \ntasm /mx startup.asm  \nThe result should be the file startup.obj  in that directory. The comma nd that's actually used to \nlink the three object files together  is shown here. Beware that the order of the object files on \nthe command line does matter in this case: the st artup code must be placed first for proper \nlinkage.  \ntlink /m /v /s ..\\Chapter3\\startup.obj led.obj blink.obj,  \n blink.exe, blink.map  \nAs a result of the tlink command, Borland's Turbo Linker will produce two new files: \nblink.exe  and blink.map  in the working directory. The fi rst file contains the relocatable \nprogram and the second contains a human-readable program map. If you have never seen such \na map file before, be sure to take a look at th is one before reading on. It provides information \nsimilar to the contents of the linker script de scribed earlier. However,  these are results and, \ntherefore, include the lengths of the sectio ns and the names and locations of the public \nsymbols found in the relocatable program.  \nOne more tool must be used to make the B linking LED program executable: a locator. The \nlocating tool we'll be using is provided by Arcom, as part of the SourceVIEW development and debugging package included with the board. Becau se this tool is designed for this one \nparticular embedded platform, it does not have as many options as a more general locator.\n[4]  \n[4] However, being free, it is also a lot cheaper than a more gene ral locator. \nProgramming Embedded Systems in C and C++ \n- 38 - In fact, there are just three parameters: the name of the relocatable binary image, the starting \naddress of the ROM (in hexadecima l) and the total size  of the destination RAM (in kilobytes):  \ntcrom blink.exe C000 128  \nSourceVIEW Borland C ROM Relocator v1.06 \nCopyright (c) Arcom Control Systems Ltd 1994 Relocating code to ROM segment C000H, data to RAM segment 100H Changing target RAM size to 128 Kbytes Opening  'blink.exe'...   Startup stack at 0102:0402   PSP Program size    550H bytes (2K)   Target RAM  size  20000H bytes (128K)   Target data size     20H bytes (1K) Creating 'blink.rom'...   ROM  image  size    550H bytes (2K)\n \nThe tcrom  locator massages the contents of the relo catable input file-assi gning base addresses \nto each section-and outputs the file blink.rom . This file contains an absolutely located binary \nimage that is ready to be loaded directly into ROM. But rather than load it into the ROM with \na device programmer, we'll create a special ASC II version of the binary image that can be \ndownloaded to the ROM over a serial port. For this we will use a utility provided by Arcom, \ncalled bin2hex . Here is the syntax of the command:  \nbin2hex blink.rom /A=1000  \nThis extra step creates a new file, called blink.hex , that contains exactly the same information \nas blink.rom , but in an ASCII representa tion called Intel Hex Format.  \nProgramming Embedded Systems in C and C++ \n- 39 -",
    "chapter describes": "various \ntechniques for downloading, executi ng, and debugging embedded software.  \n4.1 When in ROM ... \nOne of the most obvious ways to download your  embedded software is to load the binary \nimage into a read-only memory device and insert that chip into a socket on the target board. \nObviously, the contents of a truly read-onl y memory device could not be overwritten. \nHowever, as you'll see in",
    "chapter will": "be used at some point or another in \nevery embedded project. Oscilloscopes and lo gic analyzers are most often used to debug \nhardware problems - simulators during early st ages of the software development, and debug \nmonitors and emulators during the actual so ftware debugging. To be most effective, you \nshould understand what each tool is for and wh en and where to apply it for the greatest \nimpact.  \nProgramming Embedded Systems in C and C++ \n- 48 -",
    "chapter progresses": ", I will show you how to create a header f ile for the Arcom board. \nThe first section of this file is listed below. The part of the header file below describes the \nmemory map. The most notable difference betwee n the memory map in the header file and \nthat in Figure 5-2  is the format of the addresses. Pointers Versus Addresses  explains why.  \n/********************************************************************** \n *  *  Memory Map  *  *            Base Address   Size  Description  *            -------------- ----- -----------------------------------  *            0000:0000h     128K  SRAM  *            2000:0000h           Unused  *            7000:0000h           Zilog SCC Registers  *            7000:1000h           Zilog SCC Interrupt Acknowledge  *            7000:2000h           Unused  *            C000:0000h     128K  Flash  *            E000:0000h     128K  EPROM  *  **********************************************************************/  #define SRAM_BASE       (void *) 0x00000000 #define SCC_BASE        (void *) 0x70000000 \nProgramming Embedded Systems in C and C++ \n- 53 - #define SCC_INTACK      (void *) 0x70001000 \n#define FLASH_BASE      (void *) 0xC0000000 #define EPROM_BASE      (void *) 0xE0000000\n \nPointers Versus Addresses \nIn both C and C++, the value of a pointer is  an address. So when we say that we \nhave a pointer to some data, we really m ean that we have the address at which the \ndata is stored. But programmers don't us ually set or examine these addresses \ndirectly. The exception to this rule are th e developers of operating systems, device \ndrivers, and embedded software, who someti mes need to set the value of a pointer \nexplicitly in their code.  \nUnfortunately, the exact repres entation of an address can change from processor to \nprocessor or can even be compiler depende nt. This means that a physical address \nlike 12345h might not be stored in exactly that form, or might even be stored \ndifferently by different compilers.[2] The issue that then ar ises is how a programmer \ncan set the value of a pointer explicitly so that it points to the desired location in the \nmemory map.  \nMost C/C++ compilers for 80x86 processors use 32-bit pointers. However, the older \nprocessors don't have a simple linear 32- bit address space. For example, Intel's \n80188EB processor has only a 20-bit address space. And, in addition, none of its \ninternal registers can hold more than 16 bits. So on this processor, two 16-bit \nregisters-a segment register and an offset register-are combined  to create the 20-bit \nphysical address. (The physical address computation involves left-shifting the \ncontents of the segment register by four b its and adding the contents of the offset \nregister to the result. Any overflow into the 21st bit is ignored.)  \nTo declare and initialize a pointer to a register located at physical address 12345h \nwe therefore write:  \nint * pRegister = (int *) 0x10002345;  \nwhere the leftmost 16 bits contain the segment value and the rightmost 16 bits \ncontain the offset value.  \nFor convenience, 80x86 programmers sometimes write addresses as segment:offset \npairs. Using this notation, the physic al address 12345h would be written as \n0x1000:2345 . This is precisely the value-sans colon-that we used to initialize the \npointer above. However, for each possible physical address there are 4096 distinct \nsegment:offset pairs that point to a given physical address. For example, the pairs \n0x1200:0345  and 0x1234:0005  (and 4093 others) also refer to physical address \n12345h.  \nProgramming Embedded Systems in C and C++ \n- 54 - [2] This situation gets even more complicated if you consider the various memory models provided by some processors. All of \nthe examples in this book assume that the 80188's large memory model is used. In this memory model all of the specifics I'm \nabout to tell you hold for all pointer types. But in the other memory models, the format of the address stored in a pointer \ndiffers depending upon the type of code or data pointed to!  \n5.2.2 I/O Map  \nIf a separate I/O space is presen t, it will be necessary to repeat  the memory map exercise to \ncreate an I/O map for the board as well. The pr ocess is exactly the same. Simply create a table \nof peripheral names and address ra nges, organized in such a way that the lowest addresses are \nat the bottom. Typically, a large percentage of the I/O space will be unused because most of \nthe peripherals located there will ha ve only a handful of registers.  \nThe I/O map for the Arcom board is shown in Figure 5-3 . It includes three devices: the \nperipheral control block (PCB), pa rallel port, and debugger port. Th e PCB is a set of registers \nwithin the 80188EB that are used to control the on-chip peripheral s. The chips th at control the \nparallel port and debugger port re side outside of the processo r. These ports are used to \ncommunicate with the printer and a host-based debugger, respectively.  \nFigure 5-3. I/O map for the Arcom board  \n \nThe I/O map is also useful when creating the he ader file for your board. Each region of the \nI/O space maps directly to a cons tant, called the base address. The translation of the above I/O \nmap into a set of constants can be  found in the following listing:  \n/********************************************************************** \n *  *  I/O Map  *  *            Base Address    Description  *            --------------- ---------------------------------------- \nProgramming Embedded Systems in C and C++ \n- 55 -  *            0000h           Unused         \n *            FC00h           SourceVIEW Debugger Port (SVIEW)  *            FD00h           Parallel I/O Port (PIO)  *            FE00h           Unused  *            FF00h           Peripheral Control Block (PCB)  *  **********************************************************************/  #define SVIEW_BASE   0xFC00 #define PIO_BASE     0xFD00 #define PCB_BASE     0xFF00\n \n5.3 Learn How to Communicate \nNow that you know the names and addresses of th e memory and peripher als attached to the \nprocessor, it is time to learn how to comm unicate with the latter. There are two basic \ncommunication techniques: polling a nd interrupts. In either case, the processor usually issues \nsome sort of commands to the device-by way of the memory or I/O space-and waits for the device to complete the assigned task. For exampl e, the processor might ask a timer to count \ndown from 1000 to 0. Once the countdown begins, the processor is interested in just one thing: \nis the timer finished counting yet?  \nIf polling is used, then the pro cessor repeatedly checks to see if the task has been completed. \nThis is analogous to the small child who repeat edly asks \"are we there yet?\" throughout a long \ntrip. Like the child, the proce ssor spends a large am ount of otherwise useful time asking the \nquestion and getting a negative response. To implement polling in software, you need only \ncreate a loop that reads the st atus register of the device in question. Here is an example:  \n    do \n    {         // Play games, read, listen to music, etc.          ...          // Poll to see if we're there yet.         status = areWeThereYet();      } while (status == NO);\n \nThe second communication technique uses inte rrupts. An interrupt is an asynchronous \nelectrical signal from a peripheral to the pro cessor. When interrupts are used, the processor \nissues commands to the peripheral exactly as befo re, but then waits for an interrupt to signal \ncompletion of the assigned work. While the proce ssor is waiting for the interrupt to arrive, it \nis free to continue working on ot her things. When the interrupt signal is finally asserted, the \nprocessor temporarily sets aside its current work and executes a small piece of software called \nProgramming Embedded Systems in C and C++ \n- 56 - the interrupt service routine (ISR). When the ISR completes, the processor returns to the work \nthat was interrupted.  \nOf course, this isn't all automatic. The progra mmer must write the ISR himself and \"install\" \nand enable it so that it will be executed when th e relevant interrupt occurs. The first few times \nyou do this, it will be a significan t challenge. But, even so, th e use of interrupts generally \ndecreases the complexity of one's overall code by giving it a better structure. Rather than \ndevice polling being embedded within an unrelat ed part of the program, the two pieces of \ncode remain appropriately separate.  \nOn the whole, interrupts are a much more e fficient use of the processor than polling. The \nprocessor is able to use a larger percentage  of its waiting time to perform useful work. \nHowever, there is some overhead associated  with each interrupt. It takes a good bit of \ntime-relative to the length of time it takes to execute an opcode-to put aside the processor's current work and transfer control to the inte rrupt service routine. Many of the processor's \nregisters must be saved in memory, and lower-p riority interrupts must be disabled. So in \npractice both methods are used frequently. Interrupts are used when efficiency is paramount \nor multiple devices must be monitored simultaneously. Polling is used when the processor \nmust respond to some event more quickly  than is possible using interrupts.  \n5.3.1 Interrupt Map  \nMost embedded systems have only a handful of in terrupts. Associated with each of these are \nan interrupt pin (on the outside of  the processor chip) and an ISR. In order for the processor to \nexecute the correct ISR, a mapping must exist between interrupt pins and ISRs. This mapping \nusually takes the form of an interrupt vector tabl e. The vector table is usually just an array of \npointers to functions, located at some known memory address. The processor uses the \ninterrupt type (a unique number a ssociated with each interrupt pin)  as its index into this array. \nThe value stored at that location in the vector ta ble is usually just the a ddress of the ISR to be \nexecuted.[3]  \n[3] A few processors actually have the first few instructions of t he ISR stored there, rather than a pointer to the routine. \nIt is important to initialize the interrupt vect or table correctly. (If it is done incorrectly, the \nISR might be executed in response to the wrong in terrupt or never execut ed at all.) The first \npart of this process is to crea te an interrupt map that organizes the relevant information. An \ninterrupt map is a table that c ontains a list of interrupt types and the devices to which they \nrefer. This information should be included in the documentation provided with the board. \nTable 5-1  shows the interrupt map for the Arcom board.  \nProgramming Embedded Systems in C and C++ \n- 57 - Table 5-1. Interrupt Map for the Arcom Board  \nInterrupt Type Generating Device \n8 Timer/Counter #0 \n17 Zilog 85230 SCC \n18 Timer/Counter #1 \n19 Timer/Counter #2 \n20 Serial Port Receive \n21 Serial Port Transmit \nOnce again, our goal is to translate the information in the table into a form that is useful for \nthe programmer. After constr ucting an interrupt map like the one above, you should add a \nthird section to the board-specific header file. Each line of the interrupt map becomes a single \n#define  within the file, as shown:  \n/********************************************************************** \n *  *  Interrupt Map  *  **********************************************************************/  /*  * Zilog 85230 SCC  */ #define SCC_INT         17  /*   * On-Chip Timer/Counters  */ #define TIMER0_INT       8 #define TIMER1_INT      18 #define TIMER2_INT      19  /*   * On-Chip Serial Ports  */ #define RX_INT          20 #define TX_INT          21\n \n5.4 Get to Know the Processor \nProgramming Embedded Systems in C and C++ \n- 58 - If you haven't worked with the processor on your  board before, you should take some time to \nget familiar with it now. This shouldn't take very long if you do all of your programming in C \nor C++. To the user of a high-level language, most processors look and act pretty much the \nsame. However, if you'll be doing any assembly language programming, you will need to \nfamiliarize yourself with the processor's architecture and basic instruction set.  \nEverything you need to know about the processo r can be found in the databooks provided by \nthe manufacturer. If you don't have a databook or programmer's guide for your processor \nalready, you should obtain one immediately. If you are going to be a successful embedded \nsystems programmer, you must be able to r ead databooks and get something out of them. \nProcessor databooks are usually well written-as databooks go-so th ey are an ideal place to \nstart. Begin by flipping through th e databook and noting the sections that are most relevant to \nthe tasks at hand. Then go back and begin reading the processo r overview section.  \n5.4.1 Processors in General  \nMany of the most common processors are members of families of related devices. In some \ncases, the members of such a processor family represent points along an  evolutionary path. \nThe most obvious example is Intel's 80x86 famil y, which spans from the original 8086 to the \nPentium II-and beyond. In fact, the 80x86 family ha s been so successful that it has spawned \nan entire industry of imitators.  \nAs it is used in this book, the term processor  refers to any of three types of devices known as \nmicroprocessors, microcontrollers, and digital signal processors. The name microprocessor is \nusually reserved for a chip that contains a pow erful CPU that has not been designed with any \nparticular computation in mi nd. These chips are usually the foundation of personal computers \nand high-end workstations. The most common mic roprocessors are members of Motorola's \n68k-found in older Macintosh computers-and the ubiquitous 80x86 families.  \nA microcontroller is very mu ch like a microprocessor, excep t that it has been designed \nspecifically for use in embedded systems. Micr ocontrollers typically include a CPU, memory \n(a small amount of RAM, ROM, or both), and othe r peripherals in the same  integrated circuit. \nIf you purchase all of these item s on a single chip, it is possibl e to reduce the cost of an \nembedded system substantially. Among the most  popular microcontrollers are the 8051 and \nits many imitators and Motorola's 68HCxx series. It is also common to find microcontroller \nversions of popular microprocessors. For exampl e, Intel's 386EX is a microcontroller version \nof the very successful 80386 microprocessor.  \nThe final type of processor is a digital signal  processor, or DSP. The CPU within a DSP is \nspecially designed to perform di screte-time signal processing calculations-like those required \nfor audio and video communications-extremely fast. Because DSPs can perform these types of calculations much faster than other pr ocessors, they offer a powerful, low-cost \nmicroprocessor alternative for designers of  modems and other telecommunications and \nProgramming Embedded Systems in C and C++ \n- 59 - multimedia equipment. Two of the most common DSP families are the TMS320Cxx and \n5600x series from TI and Motorola, respectively.  \n5.4.2 Intel's 80188EB Processor  \nThe processor on the Arcom board is an Inte l 80188EB-a microcontroller version of the \n80186. In addition to the CPU, the 80188EB cont ains an interrupt control unit, two \nprogrammable I/O ports, three timer/counters, tw o serial ports, a DRAM controller, and a \nchip-select unit. These extra hardware device s are located within the same chip and are \nreferred to as on-chip peripherals. The CPU is  able to communicate with and control the \non-chip peripherals directly, via internal buses.  \nAlthough the on-chip peripherals are distinct hardware devices, they  act like little extensions \nof the 80186 CPU. The software can control th em by reading and writ ing a 256-byte block of \nregisters known as the periphe ral control block (PCB). You ma y recall that we encountered \nthis block when we first discussed the memory  and I/O maps for the board. By default the \nPCB is located in the I/O space, beginning at address FF00h. However, if so desired, the PCB \ncan be relocated to any convenient addre ss in either the I/O or memory space.  \nThe control and status registers for each of the on-chip peripher als are located at fixed offsets \nfrom the PCB base address. The exact offset of each register can be found in a table in the 80188EB Microprocessor User's Manual. To isol ate these details from your application \nsoftware, it is good practice to include the offset s of any registers you wi ll be using in the \nheader file for your board. I have done this fo r the Arcom board, but only  those registers that \nwill be discussed in later chapte rs of the book are shown here:  \n/********************************************************************** \n *  *  On-Chip Peripherals  *  **********************************************************************/  /*   * Interrupt Control Unit      */ #define EOI     (PCB_BASE + 0x02) #define POLL    (PCB_BASE + 0x04) #define POLLSTS (PCB_BASE + 0x06)  #define IMASK   (PCB_BASE + 0x08) #define PRIMSK  (PCB_BASE + 0x0A)  #define INSERV  (PCB_BASE + 0x0C) #define REQST   (PCB_BASE + 0x0E) \nProgramming Embedded Systems in C and C++ \n- 60 - #define INSTS   (PCB_BASE + 0x10) \n /*   * Timer/Counters   */ #define TCUCON  (PCB_BASE + 0x12)  #define T0CNT   (PCB_BASE + 0x30) #define T0CMPA  (PCB_BASE + 0x32) #define T0CMPB  (PCB_BASE + 0x34) #define T0CON   (PCB_BASE + 0x36)  #define T1CNT   (PCB_BASE + 0x38) #define T1CMPA  (PCB_BASE + 0x3A) #define T1CMPB  (PCB_BASE + 0x3C) #define T1CON   (PCB_BASE + 0x3E)  #define T2CNT   (PCB_BASE + 0x40) #define T2CMPA  (PCB_BASE + 0x42) #define T2CON   (PCB_BASE + 0x46)  /*   * Programmable I/O Ports           */ #define P1DIR   (PCB_BASE + 0x50) #define P1PIN   (PCB_BASE + 0x52) #define P1CON   (PCB_BASE + 0x54) #define P1LTCH  (PCB_BASE + 0x56)  #define P2DIR   (PCB_BASE + 0x58) #define P2PIN   (PCB_BASE + 0x5A) #define P2CON   (PCB_BASE + 0x5C) #define P2LTCH  (PCB_BASE + 0x5E)\n \nOther things you'll want to learn about the processor from its databook are:  \nWhere should the interrupt vector table be located ? Does it have to be located at a specific \naddress in memory? If not, how does th e processor know where to find it?  \nWhat is the format of the interrupt vector table?  Is it just a table of poi nters to ISR functions?  \nAre there any special interrupts, sometimes cal led traps, that are generated within the \nprocessor itself? Must an ISR be written to handle each of these?  \nHow are interrupts enabled and disabl ed (globally and individually)?  \nProgramming Embedded Systems in C and C++ \n- 61 - How are interrupts acknowledged or cleared?  \n5.5 Study the External Peripherals \nAt this point, you've studied every aspect of the new hardware except th e external peripherals. \nThese are the hardware devices that reside ou tside the processor chip and communicate with it \nby way of interrupts and I/O or memory-mapped registers.  \nBegin by making a list of the external peri pherals. Depending on your application, this list \nmight include LCD or keyboard controllers, A/ D converters, network interface chips, or \ncustom ASICs (Application-Specif ic Generated Circuits). In th e case of the Arcom board, the \nlist contains just three items: the Zilog 85230 Serial Controller,  parallel port, and debugger \nport.  \nYou should obtain a copy of the user's manua l or databook for each device on your list. At \nthis early stage of the project, your goal in reading these docum ents is to understand the basic \nfunctions of the device. What does the device do ? What registers are used to issue commands \nand receive the results? What do the various bits and larger fields within these registers mean? \nWhen, if ever, does the device generate in terrupts? How are interrupts acknowledged or \ncleared at the device?  \nWhen you are designing the embedded software , you should try to break the program down \nalong device lines. It is usua lly a good idea to associate a software module called a device \ndriver with each of the external peripherals. Th is is nothing more than a collection of software \nroutines that control the operati on of the peripheral and isolate the application software from \nthe details of that particular hardware device. I'll have a lot more to say about device drivers \nin",
    "chapter should": "work with any Flash memory device . The specific features \nof the AMD 29F010 are hidden from  that level, as desired.  \nDevice drivers for embedded systems are quite di fferent from their workstation counterparts. \nIn a modern computer workstation, device driv ers are most often concerned with satisfying \nthe requirements of the operating system. For example, workstation operating systems \ngenerally impose strict requirements on the so ftware interface between themselves and a \nnetwork card. The device driver for a particular network card mu st conform to this software \ninterface, regardless of the f eatures and capabilities of the underlying hardware. Application \nprograms that want to use the network card ar e forced to use the networking API provided by \nthe operating system and don't have direct access to  the card itself. In th is case, the goal of \nhiding the hardware completely is easily met.  \nBy contrast, the application software in an embedded system can easily access your hardware. \nIn fact, because all of the softwa re is linked together into a singl e binary image, there is rarely \neven a distinction made between  application software, operati ng system, and device drivers. \nThe drawing of these lines and the enforcement of hardware access restrictions are purely the \nresponsibilities of the software developers. Both are design decisi ons that the developers must \nconsciously make. In other words, the implemen ters of embedded software can more easily \ncheat on the software design th an their non-embedded peers.  \nThe benefits of good device driver design are th reefold. First, because of the modularization, \nthe structure of the overall software is easier to understand. Second, because there is only one \nmodule that ever interacts directly with the peripheral's regist ers, the state of the hardware can \nbe more accurately tracked. And, last but not least, software changes that result from hardware changes are localized to the device driv er. Each of these benefits can and will help \nto reduce the total number of bugs in your embe dded software. But you have to be willing to \nput in a bit of extra effort at design ti me in order to realize such savings.  \nIf you agree with the philosophy of  hiding all hardware specifics and interactions within the \ndevice driver, it will usually consist of the fi ve components in the following list. To make \nProgramming Embedded Systems in C and C++ \n- 96 - driver implementation as simple and incremen tal as possible, these elements should be \ndeveloped in the order in which they are presented.  \n1. A data structure that overlays the memory-mapped control and status registers of the device   \nThe first step in the driver developm ent process is to create a C-style struct  that looks just \nlike the memory-mapped registers of your devi ce. This usually invol ves studying the data \nbook for the peripheral and cr eating a table of the c ontrol and status regist ers and their offsets. \nThen, beginning with the register at the lowest offset, start filling out the struct . (If one or \nmore locations are unused or reserved, be sure  to place dummy variables there to fill in the \nadditional space.)  \nAn example of such a data structure is shown be low. This structure describes the registers in \none of the on-chip timer/counter units within  the 80188EB processor. The device has three \nregisters, arranged as shown in the TimerCounter  data structure below. Each register is 16 \nbits wide and should be trea ted as an unsigned integer,  although one of them, the control  \nregister, is actually a collection of individually significant bits.  \nstruct TimerCounter \n{     unsigned short  count;              // Current Count, offset 0x00     unsigned short  maxCountA;          // Maximum Count, offset 0x02     unsigned short  _reserved;          // Unused Space,  offset 0x04     unsigned short  control;            // Control Bits,  offset 0x06 };\n \nTo make the bits within the control regist er easier to read and write individually, we \nmight also define the following bitmasks:  \n#define TIMER_ENABLE    0xC000          // Enable the timer. \n#define TIMER_DISABLE   0x4000          // Disable the timer. #define TIMER_INTERRUPT 0x2000          // Enable timer interrupts. #define TIMER_MAXCOUNT  0x0020          // Timer complete? #define TIMER_PERIODIC  0x0001          // Periodic timer?\n \n2. A set of variables to track the curren t state of the hardware and device driver   \nThe second step in the driver development pr ocess is to figure out what variables you \nwill need to track the state of  the hardware and device driver. For example, in the case \nof the timer/counter unit described earlier we 'll probably need to know if the hardware \nhas been initialized. And if it has been, we might also want to know the length of the \nrunning countdown.  \nSome device drivers create more than one so ftware device. This is a purely logical \ndevice that is implemented over the top of the basic peripheral hardware. For example, \nit is easy to imagine that more than one so ftware timer could be  created from a single \nProgramming Embedded Systems in C and C++ \n- 97 - timer/counter unit. The timer/counter unit woul d be configured to generate a periodic \nclock tick, and the device driver would then manage a set of software timers of various \nlengths by maintaining state information for each.  \n3. A routine to initialize the hardware to a known state  \nOnce you know how you'll track the state of th e physical and logical devices, it's time \nto start writing the functions that actually in teract with and control the device. It is \nprobably best to begin with the hardware in itialization routine. You'll need that one \nfirst anyway, and it's a good way to get familiar with the device interaction.  \n4. A set of routines that, taken together, provide an API for users of the device driver   \nAfter you've successfully initialized th e device, you can start adding other \nfunctionality to the driver. Hopefully, you've already settled on the names and \npurposes of the various routines, as well as  their respective parameters and return \nvalues. All that's left to do now is impleme nt and test each one. We'll see examples of \nsuch routines in the next section.  \n5. One or more interrupt service routines   \nIt's best to design, implement, and test mo st of the device driver routines before \nenabling interrupts for the first time. Locati ng the source of interrupt-related problems \ncan be quite challenging. And, if you add possi ble bugs in the other driver modules to \nthe mix, it could even approach impossible. It's  far better to use polling to get the guts \nof the driver working. That way you'll know how the device works (and that it is \nindeed working) when you start looking for the source of your interrupt problems. \nAnd there will almost certainly be some of those.  \n7.3 A Simple Timer Driver \nThe device driver example that we're about to  discuss is designed to control one of the \ntimer/counter units contained within the 80188EB pr ocessor. I have chosen to implement this \ndriver-and all of the remaining examples in the book-in C++. Although C++ offers no \nadditional assistance over C in accessing hardwa re registers, there are many good reasons to \nuse it for this type of abstraction. Most notab ly, C++ classes allow us  to hide the actual \nhardware interface more completely than any C features or programming techniques. For \nexample, a constructor can be included to au tomatically configure the hardware each time a \nnew timer object is declared. This eliminates the need for an explicit call from the application \nsoftware to the driver initializa tion routine. In additi on, it is possible to hide  the data structure \nthat corresponds to the de vice registers within the private part of the a ssociated class. This \nhelps to prevent the application programmer from accidentally reading or writing the device \nregisters from some othe r part of the program.  \nProgramming Embedded Systems in C and C++ \n- 98 - The definition of the Timer  class is as follows:  \nenum TimerState { Idle, Active, Done }; \nenum TimerType  { OneShot, Periodic };  class Timer {     public:          Timer();         ~Timer();          int   start(unsigned int nMilliseconds, TimerType = OneShot);         int   waitfor();         void  cancel();          TimerState    state;         TimerType     type;         unsigned int  length;          unsigned int  count;         Timer *       pNext;      private:          static void interrupt  Interrupt(); };\n \nBefore discussing the implementatio n of this class, let's examine the previous declaration and \nconsider the device driver's overall structure. Th e first thing we see are two enumerated types, \nTimerState  and TimerType . The main purpose of these types is to make the rest of the code \nmore readable. From them we learn that  each software timer has a current state- Idle , Active , \nor Done -and a type- OneShot  or Periodic . The timer's type tells the driver what to do with the \ntimer when it expires; a Periodic  timer is to be restarted then.  \nThe constructor for the Timer  class is also the device driver's initialization routine. It ensures \nthat the timer/counter hardware is actively generating a clock tick every 1 millisecond. The \nother public methods of the class- start, waitfor , and cancel - provide an API for an easy-to-use \nsoftware timer. These methods allow applicati on programmers to start one-shot and periodic \ntimers, wait for them to expire, and cancel running timers, respectively. This is a much \nsimpler and more generic interface than that provided by the timer/counter hardware within \nthe 80188EB chip. For one thing, the timer hard ware does not know about human units of \ntime, like milliseconds. But because the timer driv er hides the specifics of this particular \nhardware, the application programmer need never even know about that.  \nProgramming Embedded Systems in C and C++ \n- 99 - The data members of the class should also help  give you some insight into the device driver \nimplementation. The first three items are variab les that answer the following questions about \nthis software timer:  \nWhat is the timer's current stat e (idle, active, or done)?  \nWhat type of a timer is it (one-shot or periodic)?  \nWhat is the total length of the timer (in units called ticks)?  \nFollowing those are two more data members, both of which contain information that is \nspecific to this implementation of the timer driver. The values of count  and pNext  have \nmeaning only within the context of  a linked list of active software timers. This linked list is \nordered by the number of ticks remaining for each timer. So count  contains information \nabout the number of ticks remaining before  this software timer is set to expire,[1] and pNext  is \na pointer to the software timer that wi ll expire the soonest after this one.  \n[1] Specifically, it represents the number of clock ticks remainin g after all of the timers ahead of it in the list have expired.  \nFinally, there is a private method called Interrupt  -our interrupt service routine. The Interrupt  \nmethod is declared static  because it is not allowed to ma nipulate the data members of the \nindividual software timers. So, for example, th e interrupt service routine is not allowed to \nmodify the state  of any timer. By using the keyword static , this restriction is automatically \nenforced for us by the C++ compiler.  \nThe most important thing to learn from the cl ass declaration is that , although all of the \nsoftware timers are driven by the same hardware  timer/counter unit, each has its own private \ndata store. This allows the application progr ammer to create multiple simultaneous software \ntimers and the device driver to manage them  behind the scenes. Once you grasp that idea, \nyou're ready to look at the implementation of th e driver's initializati on routine, API, and \ninterrupt service routine.  \nThe constructor for the Timer  class is responsible for initia lizing both the software timer and \nthe underlying hardware. With respect to the la tter, it is responsible for configuring the \ntimer/counter unit, inserting the address of the interrupt service routin e into the interrupt \nvector table, and enabling timer interrupts. Howe ver, because this method is a constructor that \nmay be called several times (once for each of the Timer  objects declared), our implementation \nof the constructor must be smart enough to perf orm these hardware ini tializations only during \nthe very first call to it. Otherw ise, the timer/counter unit might be reset at an inopportune time \nor become out of sync with the device driver.  \nThat is the reason for the static variable bInitialized  in the following code. This variable is \ndeclared with an initial value of zero and set to one after the hardware initialization sequence \nhas been performed. Subsequent calls to the Timer  constructor will see that bInitialized  is \nno longer zero and skip that part of the initialization sequence.  \nProgramming Embedded Systems in C and C++ \n- 100 - #include \"i8018xEB.h\" \n#include \"timer.h\"  #define CYCLES_PER_TICK  (25000/4)      // Number of clock cycles per tick.  /**********************************************************************  *   * Method:      Timer()  *  * Description: Constructor for the Timer class.  *  * Notes:      *  * Returns:     None defined.  *  **********************************************************************/ Timer::Timer(void) {     static int bInitialized = 0;       //     // Initialize the new software timer.     //     state  = Idle;     type   = OneShot;     length = 0;     count  = 0;     pNext  = NULL;      //     // Initialize the timer hardware, if not previously done.     //     if (!bInitialized)     {         //         // Install the interrupt handler and enable timer interrupts.         //         gProcessor.installHandler(TIMER2_INT, Timer::Interrupt);         gProcessor.pPCB->intControl.timerControl &=                                   ~(TIMER_MASK | TIMER_PRIORITY);          //          // Initialize the hardware device (use Timer #2). \nProgramming Embedded Systems in C and C++ \n- 101 -         //  \n        gProcessor.pPCB->timer[2].count = 0;         gProcessor.pPCB->timer[2].maxCountA = CYCLES_PER_TICK;         gProcessor.pPCB->timer[2].control = TIMER_ENABLE                                            | TIMER_INTERRUPT                                           | TIMER_PERIODIC;          //         // Mark the timer hardware initialized.         //         bInitialized = 1;     } }   /* Timer() */\n \nThe global object gProcessor  is declared in a header file called i8018xEB.h . It represents the \nIntel 80188EB processor. The i8018xEB  class is something that I wrote, and it includes \nmethods to make interaction with the processo r and its on-chip periphe rals easier. One of \nthese methods is called installHandler , and its job is to insert an in terrupt service routine into the \ninterrupt vector table. This class also  includes a global da ta structure called PCB that can be \noverlaid upon the memory-mapped register s of the peripher al control block.[2] The three \nregisters associated with timer /counter unit 2 make up just one small part of this 256-byte \nstructure. (For purely aesthetic reasons, I've implemented the PCB data structure as a set of \nnested structures. Hence, the control regist er of timer/counter unit 2 is accessible as \npPCB->timer[2].control .)  \n[2] Astute readers might recall that in",
    "chapter is": "mainly a description of the code  presented herein. My \ngoal is to describe the structure of this application and its source code in such a way that there \nis no magic remaining for you. You should leave this",
    "chapter with": "a complete understanding \nof the example program and the ability to develop us eful embedded applications of your own.  \n9.1 Application Overview \nThe application we're going to discuss is not  much more complicated than the \"Hello, \nWorld!\" example found in most other programming books. It is a testament to the complexity \nof embedded software development that this ex ample comes near the end of this book, rather \nthan at its beginning. We've had to gradually bu ild our way up to the computing platform that \nmost books, and even high-level lang uage compilers, take for granted.  \nOnce you're able to write the \"Hello, World!\" pr ogram, your embedded platform starts to look \na lot like any other programming environment. The hardest parts of the embedded software \ndevelopment process-familiarizing yourself wi th the hardware, establishing a software \ndevelopment process for it, and interfacing to the individual hardware  devices-are behind you. \nYou are finally able to focus your efforts on the algorithms and user interfaces that are \nspecific to the product you're developing. In many cases, these higher-level aspects of the \nprogram can be developed on another computer platform, in parallel with the lower-level \nembedded software development we've been di scussing, and merely ported to the embedded \nsystem once both are complete.  \nFigure 9-1  contains a high-level re presentation of the \"Hello, World!\" application. This \napplication includes three device drivers, the ADEOS operating system, and two ADEOS \ntasks. The first task toggles the Arcom board's red LED at a rate of 10 Hz. The second prints \nthe string \"Hello, World!\" at 10 second interv als to a host computer  or dumb terminal \nconnected to one of the board's serial ports.  \nProgramming Embedded Systems in C and C++ \n- 135 - Figure 9-1. The \"Hello, World!\" application  \n \nIn addition to the two tasks, th ere are three device drivers show n in the figure. These control \nthe Arcom board's LEDs, timers, and serial por ts, respectively. Although it is customary to \ndraw device drivers below the operating system, I chose to place these three on the same level \nas the operating system to emphasize that they  actually depend more on ADEOS than it does \non them. In fact, the embedded operating system  doesn't even know (or care) that these \ndrivers are present in the system. This is a common feature of the device drivers and other \nhardware-specific software in an embedded system.  \nThe implementation of main  is shown below. This code simply creates the two tasks and \nstarts the operating system's scheduler. At such  a high level the code should speak for itself. \nIn fact, we've already discussed a similar code listing in the previous chapter.  \n#include \"adeos.h\" \n void  flashRed(void); void  helloWorld(void);  /*  * Create the two tasks.  */ Task  taskA(flashRed,   150, 512); Task  taskB(helloWorld, 200, 512);  /*********************************************************************  *  * Function:    main()  *  * Description: This function is responsible for starting the ADEOS  *              scheduler only.  *  * Notes:  *  * Returns:     This function will never return! \nProgramming Embedded Systems in C and C++ \n- 136 -  * \n *********************************************************************/ void main(void) {     os.start();      // This point will never be reached.  }   /* main() */\n \n9.2 Flashing the LED \nAs I said earlier, one of two th ings this application does is b link the red LED. This is done by \nthe code shown below. Here the function flashRed  is executed as a task. However, ignoring that \nand the new function name, this is almost exact ly the same Blinking LED function we studied \nin"
}